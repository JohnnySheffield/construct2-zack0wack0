// Generated by Construct 2, the HTML5 game and app creator :: http://www.scirra.com
var cr = {};
cr.plugins_ = {};
cr.behaviors = {};
(function(){
cr.vector2 = function (x, y)
{
this.x = x;
this.y = y;
cr.seal(this);
};
var v2Proto = cr.vector2.prototype;
v2Proto.offset = function (px, py)
{
this.x += px;
this.y += py;
return this;
};
v2Proto.mul = function (px, py)
{
this.x *= px;
this.y *= py;
return this;
};
cr.segments_intersect = function(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)
{
var dpx = b1x - a1x + b2x - a2x;
var dpy = b1y - a1y + b2y - a2y;
var qax = a2x - a1x;
var qay = a2y - a1y;
var qbx = b2x - b1x;
var qby = b2y - b1y;
var d = Math.abs(qay * qbx - qby * qax);
var la = qbx * dpy - qby * dpx;
var lb = qax * dpy - qay * dpx;
return Math.abs(la) < d && Math.abs(lb) < d;
};
cr.rect = function (left, top, right, bottom)
{
this.set(left, top, right, bottom);
cr.seal(this);
};
var rectProto = cr.rect.prototype;
rectProto.set = function (left, top, right, bottom)
{
this.left = left;
this.top = top;
this.right = right;
this.bottom = bottom;
};
rectProto.width = function ()
{
return this.right - this.left;
};
rectProto.height = function ()
{
return this.bottom - this.top;
};
rectProto.offset = function (px, py)
{
this.left += px;
this.top += py;
this.right += px;
this.bottom += py;
return this;
};
rectProto.intersects_rect = function (rc)
{
return !(rc.right < this.left || rc.bottom < this.top || rc.left > this.right || rc.top > this.bottom);
};
rectProto.contains_pt = function (x, y)
{
return (x >= this.left && x <= this.right) && (y >= this.top && y <= this.bottom);
};
cr.quad = function ()
{
this.tlx = 0;
this.tly = 0;
this.trx = 0;
this.try_ = 0;	// is a keyword otherwise!
this.brx = 0;
this.bry = 0;
this.blx = 0;
this.bly = 0;
cr.seal(this);
};
var quadProto = cr.quad.prototype;
quadProto.set_from_rect = function (rc)
{
this.tlx = rc.left;
this.tly = rc.top;
this.trx = rc.right;
this.try_ = rc.top;
this.brx = rc.right;
this.bry = rc.bottom;
this.blx = rc.left;
this.bly = rc.bottom;
};
quadProto.set_from_rotated_rect = function (rc, a)
{
if (a === 0)
{
this.set_from_rect(rc);
}
else
{
var sin_a = Math.sin(a);
var cos_a = Math.cos(a);
var left_sin_a = rc.left * sin_a;
var top_sin_a = rc.top * sin_a;
var right_sin_a = rc.right * sin_a;
var bottom_sin_a = rc.bottom * sin_a;
var left_cos_a = rc.left * cos_a;
var top_cos_a = rc.top * cos_a;
var right_cos_a = rc.right * cos_a;
var bottom_cos_a = rc.bottom * cos_a;
this.tlx = left_cos_a - top_sin_a;
this.tly = top_cos_a + left_sin_a;
this.trx = right_cos_a - top_sin_a;
this.try_ = top_cos_a + right_sin_a;
this.brx = right_cos_a - bottom_sin_a;
this.bry = bottom_cos_a + right_sin_a;
this.blx = left_cos_a - bottom_sin_a;
this.bly = bottom_cos_a + left_sin_a;
}
};
quadProto.offset = function (px, py)
{
this.tlx += px;
this.tly += py;
this.trx += px;
this.try_ += py;
this.brx += px;
this.bry += py;
this.blx += px;
this.bly += py;
return this;
};
quadProto.bounding_box = function (rc)
{
rc.left =   Math.min(this.tlx, this.trx,  this.brx, this.blx);
rc.top =    Math.min(this.tly, this.try_, this.bry, this.bly);
rc.right =  Math.max(this.tlx, this.trx,  this.brx, this.blx);
rc.bottom = Math.max(this.tly, this.try_, this.bry, this.bly);
};
quadProto.contains_pt = function (x, y)
{
var v0x = this.trx - this.tlx;
var v0y = this.try_ - this.tly;
var v1x = this.brx - this.tlx;
var v1y = this.bry - this.tly;
var v2x = x - this.tlx;
var v2y = y - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
var dot11 = v1x * v1x + v1y * v1y
var dot12 = v1x * v2x + v1y * v2y
var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
if ((u >= 0.0) && (v > 0.0) && (u + v < 1))
return true;
v0x = this.blx - this.tlx;
v0y = this.bly - this.tly;
var dot00 = v0x * v0x + v0y * v0y
var dot01 = v0x * v1x + v0y * v1y
var dot02 = v0x * v2x + v0y * v2y
invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
u = (dot11 * dot02 - dot01 * dot12) * invDenom;
v = (dot00 * dot12 - dot01 * dot02) * invDenom;
return (u >= 0.0) && (v > 0.0) && (u + v < 1);
};
quadProto.at = function (i, xory)
{
i = i % 4;
if (i < 0)
i += 4;
switch (i)
{
case 0: return xory ? this.tlx : this.tly;
case 1: return xory ? this.trx : this.try_;
case 2: return xory ? this.brx : this.bry;
case 3: return xory ? this.blx : this.bly;
default: return xory ? this.tlx : this.tly;
}
};
quadProto.intersects_quad = function (rhs)
{
var midx = (rhs.tlx + rhs.trx  + rhs.brx + rhs.blx) / 4;
var midy = (rhs.tly + rhs.try_ + rhs.bry + rhs.bly) / 4;
if (this.contains_pt(midx, midy))
return true;
midx = (this.tlx + this.trx  + this.brx + this.blx) / 4;
midy = (this.tly + this.try_ + this.bry + this.bly) / 4;
if (rhs.contains_pt(midx, midy))
return true;
var a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y;
var i, j;
for (i = 0; i < 4; i++)
{
for (j = 0; j < 4; j++)
{
a1x = this.at(i, true);
a1y = this.at(i, false);
a2x = this.at(i + 1, true);
a2y = this.at(i + 1, false);
b1x = rhs.at(j, true);
b1y = rhs.at(j, false);
b2x = rhs.at(j + 1, true);
b2y = rhs.at(j + 1, false);
if (cr.segments_intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y))
return true;
}
}
return false;
};
cr.RGB = function (red, green, blue)
{
return Math.max(Math.min(red, 255), 0)
| (Math.max(Math.min(green, 255), 0) << 8)
| (Math.max(Math.min(blue, 255), 0) << 16);
};
cr.shallowCopy = function (a, b, allowOverwrite)
{
var attr;
for (attr in b)
{
if (b.hasOwnProperty(attr))
{
;
a[attr] = b[attr];
}
}
};
cr.arrayRemove = function (arr, index)
{
var sliced;
if (index < 1)
arr.shift();
else
{
sliced = arr.slice(index + 1);
arr.length = index;
arr.push.apply(arr, sliced);
}
};
cr.arrayFindRemove = function (arr, item)
{
var index = jQuery.inArray(item, arr);
if (index >= 0)
cr.arrayRemove(arr, index);
};
cr.clamp = function(x, a, b)
{
if (x < a)
return a;
else if (x > b)
return b;
else
return x;
};
cr.to_radians = function(x)
{
return x / (180.0 / Math.PI);
};
cr.to_degrees = function(x)
{
return x * (180.0 / Math.PI);
};
cr.clamp_angle_degrees = function (a)
{
var angle = a;
angle %= 360;       // now in (-360, 360) range
if (angle < 0)
angle += 360;   // now in [0, 360) range
return angle;
};
cr.clamp_angle = function (a)
{
var angle = a;
angle %= 2 * Math.PI;       // now in (-2pi, 2pi) range
if (angle < 0)
angle += 2 * Math.PI;   // now in [0, 2pi) range
return angle;
};
cr.to_clamped_degrees = function (x)
{
return cr.clamp_angle_degrees(cr.to_degrees(x));
};
cr.to_clamped_radians = function (x)
{
return cr.clamp_angle(cr.to_radians(x));
};
cr.angleDiff = function (a1, a2)
{
if (a1 === a2)
return 0;
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
return Math.acos(s1 * s2 + c1 * c2);
};
cr.angleRotate = function (start, end, step)
{
var ss = Math.sin(start);
var cs = Math.cos(start);
var se = Math.sin(end);
var ce = Math.cos(end);
if (Math.acos(ss * se + cs * ce) > step)
{
if (cs * se - ss * ce > 0)
return cr.clamp_angle(start + step);
else
return cr.clamp_angle(start - step);
}
else
return cr.clamp_angle(end);
};
cr.angleClockwise = function (a1, a2)
{
var s1 = Math.sin(a1);
var c1 = Math.cos(a1);
var s2 = Math.sin(a2);
var c2 = Math.cos(a2);
return c1 * s2 - s1 * c2 <= 0;
};
cr.xor = function (x, y)
{
return !x !== !y;
};
cr.lerp = function (a, b, x)
{
return a + (b - a) * x;
};
cr.ObjectSet = function ()
{
this.items = {};
this.item_count = 0;
this.values_cache = [];
this.cache_valid = true;
cr.seal(this);
};
var ObjectSetProto = cr.ObjectSet.prototype;
ObjectSetProto.contains = function (x)
{
return this.items.hasOwnProperty(x.toString());
};
ObjectSetProto.add = function (x)
{
if (!this.contains(x))
{
this.items[x.toString()] = x;
this.item_count++;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.remove = function (x)
{
if (this.contains(x))
{
delete this.items[x.toString()];
this.item_count--;
this.cache_valid = false;
}
return this;
};
ObjectSetProto.clear = function ()
{
this.items = {};
this.item_count = 0;
this.values_cache.length = 0;
this.cache_valid = true;
return this;
};
ObjectSetProto.isEmpty = function ()
{
return this.item_count === 0;
};
ObjectSetProto.count = function ()
{
return this.item_count;
};
ObjectSetProto.values = function ()
{
if (!this.cache_valid)
{
this.values_cache.length = 0;
var i;
for (i in this.items)
{
if (this.items.hasOwnProperty(i))
this.values_cache.push(this.items[i]);
}
this.cache_valid = true;
}
return this.values_cache.slice(0);
};
cr.KahanAdder = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
cr.seal(this);
};
var KahanProto = cr.KahanAdder.prototype;
KahanProto.add = function (v)
{
this.y = v - this.c;
this.t = this.sum + this.y;
this.c = (this.t - this.sum) - this.y;
this.sum = this.t;
};
KahanProto.reset = function ()
{
this.c = 0;
this.y = 0;
this.t = 0;
this.sum = 0;
};
cr.seal = function(x)
{
if (Object.seal)
return Object.seal(x);
else
return x;
};
cr.freeze = function(x)
{
if (Object.freeze)
return Object.freeze(x);
else
return x;
};
cr.regexp_escape = function(text)
{
return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
};
}());
;
(function()
{
cr.createRuntime = function (canvasid)
{
return new cr.runtime(document.getElementById(canvasid));
};
cr.runtime = function (canvas)
{
if (!canvas || !canvas.getContext)
return;
this.canvas = canvas;
this.ctx = canvas.getContext("2d");
canvas.c2runtime = this;
this.width = canvas.width;
this.height = canvas.height;
this.redraw = true;
if (!Date.now) {
Date.now = function now() {
return +new Date();
};
}
this.plugins = [];
this.types = {};
this.types_by_index = [];
this.behaviors = [];
this.layouts = {};
this.layouts_by_index = [];
this.eventsheets = {};
this.eventsheets_by_index = [];
this.wait_for_textures = [];        // for blocking until textures loaded
this.triggers_to_postinit = [];
this.deathRow = new cr.ObjectSet();
this.dt = 0;                
this.dt1 = 0;
this.zeroDtCount = 0;
this.timescale = 1.0;
this.kahanTime = new cr.KahanAdder();
this.last_tick_time = 0;
this.measuring_dt = true;
this.fps = 0;
this.last_fps_time = 0;
this.tickcount = 0;
this.framecount = 0;        // for fps
this.objectcount = 0;
this.changelayout = null;
this.destroycallbacks = [];
this.event_stack = [];
this.event_stack_index = -1;
this.pushEventStack(null);
this.loop_stack = [];
this.loop_stack_index = -1;
this.next_uid = 0;
this.layout_first_tick = true;
this.objects_to_tick = new cr.ObjectSet();
this.registered_collisions = [];
this.activeGroups = {};				// event group activation state
this.running_layout = null;			// currently running layout
this.layer_canvas = null;			// for layers "render-to-texture"
this.layer_ctx = null;
this.files_subfolder = "";			// path with project files
this.html5logo = new Image();
this.html5logo.src = "logo.png";	// only 1kb!
this.load();
this.go();
this.extra = {};
cr.seal(this);
};
var runtimeProto = cr.runtime.prototype;
runtimeProto.load = function ()
{
if (!this.ctx)
return;
;
var pm = cr.getProjectModel();
this.name = pm[0];
this.first_layout = pm[1];
this.system = new cr.system_object(this);
var i, len, j, lenj, k, lenk, idstr, m, b;
var plugin, plugin_ctor;
for (i = 0, len = pm[2].length; i < len; i++)
{
m = pm[2][i];
;
cr.add_common_aces(m);
plugin = new m[0](this);
plugin.singleglobal = m[1];
plugin.is_world = m[2];
if (plugin.onCreate)
plugin.onCreate();  // opportunity to override default ACEs
cr.seal(plugin);
this.plugins.push(plugin);
}
pm = cr.getProjectModel();
for (i = 0, len = pm[3].length; i < len; i++)
{
m = pm[3][i];
plugin_ctor = m[1];
;
plugin = null;
for (j = 0, lenj = this.plugins.length; j < lenj; j++)
{
if (this.plugins[j] instanceof plugin_ctor)
{
plugin = this.plugins[j];
break;
}
}
;
;
var type_inst = new plugin.Type(plugin);
;
type_inst.name = m[0];
if (m[2])
{
type_inst.texture_file = m[2][0];
type_inst.texture_filesize = m[2][1];
}
if (m[3])
{
type_inst.animations = m[3];
}
type_inst.index = i;                                // save index in to types array in type
type_inst.instances = [];                           // all instances of this type
type_inst.deadCache = [];							// destroyed instances to recycle next create
type_inst.solstack = [new cr.selection(type_inst)]; // initialise SOL stack with one empty SOL
type_inst.cur_sol = 0;
type_inst.default_instance = null;
type_inst.stale_iids = true;
type_inst.updateIIDs = cr.type_updateIIDs;
type_inst.getFirstPicked = cr.type_getFirstPicked;
type_inst.getPairedInstance = cr.type_getPairedInstance;
type_inst.getCurrentSol = cr.type_getCurrentSol;
type_inst.pushCleanSol = cr.type_pushCleanSol;
type_inst.pushCopySol = cr.type_pushCopySol;
type_inst.popSol = cr.type_popSol;
type_inst.getBehaviorByName = cr.type_getBehaviorByName;
type_inst.getBehaviorIndexByName = cr.type_getBehaviorIndexByName;
type_inst.behaviors = [];
for (j = 0, lenj = m[4].length; j < lenj; j++)
{
b = m[4][j];
var behavior_ctor = b[1];
var behavior_plugin = null;
for (k = 0, lenk = this.behaviors.length; k < lenk; k++)
{
if (this.behaviors[k] instanceof behavior_ctor)
{
behavior_plugin = this.behaviors[k];
break;
}
}
if (!behavior_plugin)
{
behavior_plugin = new behavior_ctor(this);
behavior_plugin.my_instances = new cr.ObjectSet(); 	// instances of this behavior
if (behavior_plugin.onCreate)
behavior_plugin.onCreate();
cr.seal(behavior_plugin);
this.behaviors.push(behavior_plugin);
}
var behavior_type = new behavior_plugin.Type(behavior_plugin, type_inst);
behavior_type.name = b[0];
behavior_type.onCreate();
cr.seal(behavior_type);
type_inst.behaviors.push(behavior_type);
}
type_inst.onCreate();
cr.seal(type_inst);
if (type_inst.name)
this.types[type_inst.name] = type_inst;
this.types_by_index.push(type_inst);
if (plugin.singleglobal)
{
var instance = new plugin.Instance(type_inst);
instance.uid = this.next_uid;
this.next_uid++;
instance.iid = 0;
instance.get_iid = cr.inst_get_iid;
instance.toString = cr.inst_toString;
instance.onCreate();
cr.seal(instance);
type_inst.instances.push(instance);
}
}
for (i = 0, len = pm[4].length; i < len; i++)
{
m = pm[4][i];
var layout = new cr.layout(this, m);
cr.seal(layout);
this.layouts[layout.name] = layout;
this.layouts_by_index.push(layout);
}
for (i = 0, len = pm[5].length; i < len; i++)
{
m = pm[5][i];
var sheet = new cr.eventsheet(this, m);
cr.seal(sheet);
this.eventsheets[sheet.name] = sheet;
this.eventsheets_by_index.push(sheet);
}
for (i = 0, len = this.eventsheets_by_index.length; i < len; i++)
this.eventsheets_by_index[i].postInit();
for (i = 0, len = this.triggers_to_postinit.length; i < len; i++)
this.triggers_to_postinit[i].postInit();
delete this.triggers_to_postinit;
this.files_subfolder = pm[6];
this.start_time = Date.now();
};
runtimeProto.areAllTexturesLoaded = function ()
{
var totalsize = 0;
var completedsize = 0;
var ret = true;
var i, len;
for (i = 0, len = this.wait_for_textures.length; i < len; i++)
{
var filesize = this.wait_for_textures[i].cr_filesize;
if (!filesize || filesize <= 0)
filesize = 50000;
totalsize += filesize;
if (this.wait_for_textures[i].complete)
completedsize += filesize;
else
ret = false;    // not all textures loaded
}
if (totalsize == 0)
this.progress = 0;
else
this.progress = (completedsize / totalsize);
return ret;
};
runtimeProto.go = function ()
{
if (!this.ctx)
return;
this.progress = 0;
this.last_progress = -1;
if (this.areAllTexturesLoaded())
this.go_textures_done();
else
{
var ms_elapsed = Date.now() - this.start_time;
if ((ms_elapsed >= 500 && this.html5logo.complete) && this.last_progress != this.progress)
{
this.ctx.clearRect(0, 0, this.width, this.height);
var mx = this.width / 2;
var my = this.height / 2;
var hlw = this.html5logo.width / 2;
var hlh = this.html5logo.height / 2;
this.ctx.drawImage(this.html5logo, Math.floor(mx - hlw), Math.floor(my - hlh));
my += hlh + 12;
mx -= hlw;
mx = Math.floor(mx) + 0.5;
my = Math.floor(my) + 0.5;
this.ctx.fillStyle = "blue";
this.ctx.fillRect(mx, my, Math.floor(this.html5logo.width * this.progress), 6);
this.ctx.strokeStyle = "black";
this.ctx.strokeRect(mx, my, this.html5logo.width, 6);
this.ctx.strokeStyle = "white";
this.ctx.strokeRect(mx - 1, my - 1, this.html5logo.width + 2, 8);
this.last_progress = this.progress;
}
setTimeout((function (self) { return function () { self.go(); }; })(this), 100);
}
};
runtimeProto.go_textures_done = function ()
{
if (this.first_layout)
this.layouts[this.first_layout].startRunning();
else
this.layouts_by_index[0].startRunning();
;
this.start_time = Date.now();
this.last_fps_time = this.start_time;       // for counting framerate
this.tick();
};
runtimeProto.tick = function ()
{
;
this.logic();
if (this.redraw)
{
this.draw();
this.redraw = false;
}
this.tickcount++;
this.framecount++;
var raf = window.requestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.webkitRequestAnimationFrame ||
window.msRequestAnimationFrame     ||
window.oRequestAnimationFrame;
if (raf)
raf((function (self) { return function () { self.tick(); }; })(this), this.canvas);
else
setTimeout((function (self) { return function () { self.tick(); }; })(this), 16);
};
runtimeProto.logic = function ()
{
var i, leni, j, lenj, k, lenk;
var cur_time = Date.now();
if (cur_time - this.last_fps_time >= 1000)  // every 1 second
{
this.last_fps_time += 1000;
this.fps = this.framecount;
this.framecount = 0;
}
if (this.measuring_dt)
{
if (this.last_tick_time !== 0)
{
var ms_diff = cur_time - this.last_tick_time;
if (ms_diff === 0)
{
this.zeroDtCount++;
if (this.zeroDtCout >= 10)
this.measuring_dt = false;
this.dt1 = 1.0 / 60.0;            // 60fps assumed (0.01666...)
;
}
else
{
this.dt1 = ms_diff / 1000.0; // dt measured in seconds
if (this.dt1 > 0.1)
this.dt1 = 0.1;
}
}
this.last_tick_time = cur_time;
}
this.dt = this.dt1 * this.timescale;
this.kahanTime.add(this.dt);
this.ClearDeathRow();
this.system.runWaits();
if (this.changelayout)
{
;
this.running_layout.stopRunning();
this.changelayout.startRunning();
this.changelayout = null;
this.redraw = true;
this.layout_first_tick = true;
}
for (i = 0, leni = this.types_by_index.length; i < leni; i++)
{
var type = this.types_by_index[i];
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
var inst = type.instances[j];
if (!inst.behavior_insts)
continue;
for (k = 0, lenk = inst.behavior_insts.length; k < lenk; k++)
{
inst.behavior_insts[k].tick();
}
}
}
var tickarr = this.objects_to_tick.values();
for (i = 0, leni = tickarr.length; i < leni; i++)
tickarr[i].tick();
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
this.eventsheets_by_index[i].hasRun = false;
if (this.running_layout.event_sheet)
this.running_layout.event_sheet.run();
this.registered_collisions.length = 0;
this.layout_first_tick = false;
};
runtimeProto.tickMe = function (inst)
{
this.objects_to_tick.add(inst);
};
runtimeProto.getDt = function (inst)
{
if (!inst || inst.my_timescale === -1.0)
return this.dt;
return this.dt1 * inst.my_timescale;
};
runtimeProto.draw = function ()
{
this.running_layout.draw(this.ctx);
};
runtimeProto.addDestroyCallback = function (f)
{
if (f)
this.destroycallbacks.push(f);
};
runtimeProto.DestroyInstance = function (inst)
{
this.deathRow.add(inst);
};
runtimeProto.ClearDeathRow = function ()
{
var inst, index, type, instances, binst;
var i, j, leni, lenj;
var w;
var arr = this.deathRow.values();	// get array of items from set
for (i = 0, leni = arr.length; i < leni; i++)
{
inst = arr[i];
type = inst.type;
instances = type.instances;
for (j = 0, lenj = this.destroycallbacks.length; j < lenj; j++)
this.destroycallbacks[j](inst);
cr.arrayFindRemove(instances, inst);
if (inst.layer)
{
cr.arrayRemove(inst.layer.instances, inst.get_zindex());
inst.layer.zindices_stale = true;
}
if (inst.behavior_insts)
{
for (j = 0, lenj = inst.behavior_insts.length; j < lenj; j++)
{
binst = inst.behavior_insts[j];
if (binst.onDestroy)
binst.onDestroy();
binst.behavior.my_instances.remove(inst);
}
}
this.objects_to_tick.remove(inst);
for (j = 0, lenj = this.system.waits.length; j < lenj; j++)
{
w = this.system.waits[j];
if (!w.sols.hasOwnProperty(type.name))
continue;
cr.arrayFindRemove(w.sols[type.name], inst);
}
if (inst.onDestroy)
inst.onDestroy();
this.objectcount--;
if (type.deadCache.length < 32)
type.deadCache.push(inst);
}
if (!this.deathRow.isEmpty())
this.redraw = true;
this.deathRow.clear();
};
runtimeProto.createInstance = function (type, layer)
{
return this.createInstanceFromInit(type.default_instance, layer, false);
};
runtimeProto.createInstanceFromInit = function (initial_inst, layer, is_startup_instance)
{
var i, len, j, lenj;
;
var type = this.types_by_index[initial_inst[1]];
;
var is_world = type.plugin.is_world;
;
var inst;
var recycled_inst = false;
if (type.deadCache.length)
{
inst = type.deadCache.pop();
recycled_inst = true;
type.plugin.Instance.call(inst, type);
}
else
inst = new type.plugin.Instance(type);
inst.uid = this.next_uid;
this.next_uid++;
inst.iid = 0;
inst.get_iid = cr.inst_get_iid;
type.stale_iids = true;
var initial_vars = initial_inst[2];
if (recycled_inst)
{
for (i = 0, len = initial_vars.length; i < len; i++)
inst.instance_vars[i] = initial_vars[i];
}
else
inst.instance_vars = initial_vars.slice(0);
if (is_world)
{
var wm = initial_inst[0];
;
inst.x = wm[0];
inst.y = wm[1];
inst.z = wm[2];
inst.width = wm[3];
inst.height = wm[4];
inst.depth = wm[5];
inst.angle = wm[6];
inst.opacity = wm[7];
inst.hotspotX = wm[8];
inst.hotspotY = wm[9];
if (recycled_inst)
{
inst.bbox.set(0, 0, 0, 0);
inst.bquad.set_from_rect(inst.bbox);
inst.bbox_changed_callbacks.length = 0;
}
else
{
inst.bbox = new cr.rect(0, 0, 0, 0);
inst.bquad = new cr.quad();
inst.bbox_changed_callbacks = [];
inst.set_bbox_changed = cr.set_bbox_changed;
inst.add_bbox_changed_callback = cr.add_bbox_changed_callback;
inst.contains_pt = cr.inst_contains_pt;
inst.update_bbox = cr.update_bbox;
inst.get_zindex = cr.inst_get_zindex;
}
inst.bbox_changed = true;
inst.visible = true;
inst.my_timescale = -1.0;
inst.layer = layer;
inst.zindex = layer.instances.length;	// will be placed at top of current layer
this.redraw = true;
}
inst.toString = cr.inst_toString;
var initial_props, binst;
if (recycled_inst)
{
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
binst = inst.behavior_insts[i];
btype.behavior.Instance.call(binst, btype, inst);
initial_props = initial_inst[3][i];
for (j = 0, lenj = initial_props.length; j < lenj; j++)
binst.properties[j] = initial_props[j];
binst.onCreate();
btype.behavior.my_instances.add(inst);
}
}
else
{
inst.behavior_insts = [];
for (i = 0, len = type.behaviors.length; i < len; i++)
{
var btype = type.behaviors[i];
var binst = new btype.behavior.Instance(btype, inst);
binst.properties = initial_inst[3][i].slice(0);
binst.onCreate();
cr.seal(binst);
inst.behavior_insts.push(binst);
btype.behavior.my_instances.add(inst);
}
}
initial_props = initial_inst[4];
if (recycled_inst)
{
for (i = 0, len = initial_props.length; i < len; i++)
inst.properties[i] = initial_props[i];
}
else
inst.properties = initial_props.slice(0);
type.instances.push(inst);
if (layer)
layer.instances.push(inst);
this.objectcount++;
inst.onCreate();
if (!recycled_inst)
cr.seal(inst);
return inst;
};
runtimeProto.getLayerByName = function (layer_name)
{
var i, len;
for (i = 0, len = this.running_layout.layers.length; i < len; i++)
{
var layer = this.running_layout.layers[i];
if (layer.name === layer_name)
return layer;
}
return null;
};
runtimeProto.getLayerByNumber = function (index)
{
index = Math.floor(index);
if (index < 0)
index = 0;
if (index >= this.running_layout.layers.length)
index = this.running_layout.layers.length - 1;
return this.running_layout.layers[index];
};
runtimeProto.getLayer = function (l)
{
if (typeof l === "number")
return this.getLayerByNumber(l);
else
return this.getLayerByName(l.toString());
};
cr.layout = function (runtime, m)
{
this.runtime = runtime;
this.event_sheet = null;
this.scrollX = (this.runtime.width / 2);
this.scrollY = (this.runtime.height / 2);
this.name = m[0];
this.width = m[1];
this.height = m[2];
this.unbounded_scrolling = m[3];
this.sheetname = m[4];
var lm = m[5];
var i, len;
this.layers = [];
for (i = 0, len = lm.length; i < len; i++)
{
var layer = new cr.layer(this, lm[i]);
layer.number = i;
cr.seal(layer);
this.layers.push(layer);
}
var im = m[6];
this.initial_nonworld = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_nonworld.push(inst);
}
};
var layoutProto = cr.layout.prototype;
layoutProto.startRunning = function ()
{
if (this.sheetname)
{
this.event_sheet = this.runtime.eventsheets[this.sheetname];
;
}
this.runtime.running_layout = this;
this.scrollX = (this.runtime.width / 2);
this.scrollY = (this.runtime.height / 2);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
this.layers[i].createInitialInstances();
}
for (i = 0, len = this.initial_nonworld.length; i < len; i++)
{
this.runtime.createInstanceFromInit(this.initial_nonworld[i], null, true);
}
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutStart, null);
};
layoutProto.stopRunning = function ()
{
;
this.runtime.trigger(cr.system_object.prototype.cnds.OnLayoutEnd, null);
this.runtime.system.waits.length = 0;
var i, leni, j, lenj, k, lenk;
for (i = 0, leni = this.layers.length; i < leni; i++)
{
this.layers[i].instances.length = 0;
}
var destroycallbacks = this.runtime.destroycallbacks;
for (i = 0, leni = this.runtime.types_by_index.length; i < leni; i++)
{
var type = this.runtime.types_by_index[i];
if (type.plugin.singleglobal)
continue;
this.runtime.objectcount -= type.instances.length;
for (j = 0, lenj = type.instances.length; j < lenj; j++)
{
for (k = 0, lenk = destroycallbacks.length; k < lenk; k++)
destroycallbacks[k](type.instances[j]);
delete type.instances[j];
}
type.instances.length = 0;
}
for (i = 0, leni = this.runtime.behaviors.length; i < leni; i++)
{
this.runtime.behaviors[i].my_instances.clear();
}
};
layoutProto.draw = function (ctx)
{
ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
var i, len;
for (i = 0, len = this.layers.length; i < len; i++)
{
if (this.layers[i].visible)
this.layers[i].draw(ctx);
}
};
layoutProto.getMinLayerScale = function ()
{
var m = this.layers[0].scale;
var i, len, l;
for (i = 1, len = this.layers.length; i < len; i++)
{
l = this.layers[i];
if (l.scale < m)
m = l.scale;
}
return m;
};
layoutProto.scrollToX = function (x)
{
if (!this.unbounded_scrolling)
{
var widthBoundary = (this.runtime.width * (1 / this.getMinLayerScale()) / 2);
if (x > this.width - widthBoundary)
x = this.width - widthBoundary;
if (x < widthBoundary)
x = widthBoundary;
}
if (this.scrollX !== x)
{
this.scrollX = x;
this.runtime.redraw = true;
}
};
layoutProto.scrollToY = function (y)
{		
if (!this.unbounded_scrolling)
{
var heightBoundary = (this.runtime.height * (1 / this.getMinLayerScale()) / 2);
if (y > this.height - heightBoundary)
y = this.height - heightBoundary;
if (y < heightBoundary)
y = heightBoundary;
}
if (this.scrollY !== y)
{
this.scrollY = y;
this.runtime.redraw = true;
}
};
cr.layer = function (layout, m)
{
this.layout = layout;
this.runtime = layout.runtime;
this.instances = [];        // running instances
this.scale = 1.0;
this.viewLeft = 0;
this.viewRight = 0;
this.viewTop = 0;
this.viewBottom = 0;
this.zindices_stale = false;
this.name = m[0];
this.index = m[1];
this.visible = m[2];		// initially visible
this.background_color = m[3];
this.transparent = m[4];
this.parallaxX = m[5];
this.parallaxY = m[6];
this.opacity = m[7];
this.forceOwnTexture = m[8];
var im = m[9];
var i, len;
this.initial_instances = [];
for (i = 0, len = im.length; i < len; i++)
{
var inst = im[i];
var type = this.runtime.types_by_index[inst[1]];
;
if (!type.default_instance)
type.default_instance = inst;
this.initial_instances.push(inst);
}		
};
var layerProto = cr.layer.prototype;
layerProto.createInitialInstances = function ()
{
var i, len;
for (i = 0, len = this.initial_instances.length; i < len; i++)
{
this.runtime.createInstanceFromInit(this.initial_instances[i], this, true);
}
};
layerProto.updateZIndices = function ()
{
if (!this.zindices_stale)
return;
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
{
this.instances[i].zindex = i;
}
this.zindices_stale = false;
};
layerProto.draw = function (ctx)
{
var render_offscreen = (this.forceOwnTexture || this.opacity != 1.0);
var layer_canvas = this.runtime.canvas;
var layer_ctx = ctx;
if (render_offscreen)
{
if (!this.runtime.layer_canvas)
{
this.runtime.layer_canvas = document.createElement("canvas");
;
layer_canvas = this.runtime.layer_canvas;
layer_canvas.width = this.runtime.width;
layer_canvas.height = this.runtime.height;
this.runtime.layer_ctx = layer_canvas.getContext("2d");
;
}
layer_canvas = this.runtime.layer_canvas;
layer_ctx = this.runtime.layer_ctx;
if (layer_canvas.width != this.runtime.width)
layer_canvas.width = this.runtime.width;
if (layer_canvas.height != this.runtime.height)
layer_canvas.height = this.runtime.height;
if (this.transparent)
layer_ctx.clearRect(0, 0, this.runtime.width, this.runtime.height);
}
if (!this.transparent)
{
layer_ctx.fillStyle = this.background_color;
layer_ctx.fillRect(0, 0, this.runtime.width, this.runtime.height);
}
layer_ctx.save();
var px = this.canvasToLayerX(0);
var py = this.canvasToLayerY(0);
this.viewLeft = px;
this.viewTop = py;
this.viewRight = px + (this.runtime.width * (1 / this.scale));
this.viewBottom = py + (this.runtime.height * (1 / this.scale));
layer_ctx.scale(this.scale, this.scale);
layer_ctx.translate(-px, -py);
var i, len, inst, bbox;
for (i = 0, len = this.instances.length; i < len; i++)
{
inst = this.instances[i];
if (!inst.visible)
continue;
inst.update_bbox();
bbox = inst.bbox;
if (bbox.right < this.viewLeft || bbox.bottom < this.viewTop || bbox.left > this.viewRight || bbox.top > this.viewBottom)
continue;
inst.draw(layer_ctx);
}
layer_ctx.restore();
if (render_offscreen)
{
ctx.globalAlpha = this.opacity;
ctx.drawImage(layer_canvas, 0, 0);
ctx.globalAlpha = 1.0;
}
};
layerProto.canvasToLayerX = function (ptx)
{
var ox = (this.runtime.width / 2);
var x = ((this.layout.scrollX - ox) * this.parallaxX) + ox;
var invScale = 1 / this.scale;
x -= (this.runtime.width * invScale) / 2;
return x + (ptx * invScale);
};
layerProto.canvasToLayerY = function (pty)
{
var oy = (this.runtime.height / 2);
var y = ((this.layout.scrollY - oy) * this.parallaxY) + oy;
var invScale = 1 / this.scale;
y -= (this.runtime.height * invScale) / 2;
return y + (pty * invScale);
};
runtimeProto.flip = function (img)
{
var w = img.width;
var h = img.height;
var render_canvas = document.createElement("canvas");
render_canvas.width = w;
render_canvas.height = h;
var render_ctx = render_canvas.getContext("2d");
;
render_ctx.drawImage(img, 0, 0);
var src = render_ctx.getImageData(0, 0, w, h);
var dest = render_ctx.createImageData(w, h);
var elemsPerLine = w * 4;
var x, y, linestart, srcpixel, destpixel;
for (y = 0; y < h; y++)
{
for (x = 0; x < w; x++)
{
srcpixel = (y * elemsPerLine) + (x * 4);
destpixel = (((h - 1) - y) * elemsPerLine) + (x * 4);
dest.data[destpixel+0] = src.data[srcpixel+0];
dest.data[destpixel+1] = src.data[srcpixel+1];
dest.data[destpixel+2] = src.data[srcpixel+2];
dest.data[destpixel+3] = src.data[srcpixel+3];
}
}
render_ctx.putImageData(dest, 0, 0);
var ret = new Image();
ret.src = render_canvas.toDataURL();
return ret;
};
}());
;
(function()
{
cr.eventsheet = function (runtime, m)
{
this.runtime = runtime;
this.triggers = {};
this.hasRun = false;
this.includes = new cr.ObjectSet(); // all event sheets included by this sheet, at first-level indirection only
this.name = m[0];
var em = m[1];		// events model
this.events = [];       // triggers won't make it to this array
var i, len;
for (i = 0, len = em.length; i < len; i++)
this.init_event(em[i], null, this.events);
};
var eventSheetProto = cr.eventsheet.prototype;
eventSheetProto.toString = function ()
{
return this.name;
};
eventSheetProto.init_event = function (m, parent, nontriggers)
{
switch (m[0]) {
case 0:	// event block
{
var block = new cr.eventblock(this, parent, m);
cr.seal(block);
if (block.is_trigger())
this.init_trigger(block);
else
nontriggers.push(block);
break;
}
case 1: // variable
{
var v = new cr.eventvariable(this, parent, m);
cr.seal(v);
nontriggers.push(v);
break;
}
case 2:	// include
{
var inc = new cr.eventinclude(this, parent, m);
cr.seal(inc);
nontriggers.push(inc);
break;
}
default:
;
}
};
eventSheetProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
this.events[i].postInit();
}
};
eventSheetProto.run = function ()
{
this.hasRun = true;
var i, len;
for (i = 0, len = this.events.length; i < len; i++)
{
var ev = this.events[i];
ev.run();
this.runtime.clearSol(ev.solModifiers);
}
};
cr.selection = function (type)
{
this.type = type;
this.instances = [];        // subset of picked instances
this.select_all = true;
};
var solProto = cr.selection.prototype;
solProto.hasObjects = function ()
{
if (this.select_all)
return this.type.instances.length;
else
return this.instances.length;
};
solProto.getObjects = function ()
{
if (this.select_all)
return this.type.instances;
else
return this.instances;
};
solProto.pick = function (inst)
{
;
if (this.select_all)
{
this.select_all = false;
this.instances.length = 1;
this.instances[0] = inst;
}
else
{
if (jQuery.inArray(inst, this.instances) === -1)
this.instances.push(inst);
}
};
var runtimeProto = cr.runtime.prototype;
runtimeProto.clearSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].getCurrentSol().select_all = true;
}
};
runtimeProto.pushCleanSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCleanSol();
}
};
runtimeProto.pushCopySol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].pushCopySol();
}
};
runtimeProto.popSol = function (solModifiers)
{
var i, len;
for (i = 0, len = solModifiers.length; i < len; i++)
{
solModifiers[i].popSol();
}
};
cr.eventblock = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.solWriterAfterCnds = false;	// block does not change SOL after running its conditions
;
this.conditions = [];
this.actions = [];
this.subevents = [];
if (m[1])
{
this.group_name = m[1][1];
if (m[1][0])
this.runtime.activeGroups[this.group_name] = true;
}
var i, len;
var cm = m[2];
for (i = 0, len = cm.length; i < len; i++)
{
var cnd = new cr.condition(this, cm[i]);
cr.seal(cnd);
this.conditions.push(cnd);
this.addSolModifier(cnd.type);
}
var am = m[3];
for (i = 0, len = am.length; i < len; i++)
{
var act = new cr.action(this, am[i]);
cr.seal(act);
this.actions.push(act);
}
if (m.length === 5)
{
var em = m[4];
for (i = 0, len = em.length; i < len; i++)
this.sheet.init_event(em[i], this, this.subevents);
}
};
var eventblockProto = cr.eventblock.prototype;
eventblockProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.conditions.length; i < len; i++)
this.conditions[i].postInit();
for (i = 0, len = this.actions.length; i < len; i++)
this.actions[i].postInit();
for (i = 0, len = this.subevents.length; i < len; i++)
this.subevents[i].postInit();
}
eventblockProto.addSolModifier = function (type)
{
if (!type)
return;
if (jQuery.inArray(type, this.solModifiers) === -1)
this.solModifiers.push(type);
};
eventblockProto.setSolWriterAfterCnds = function ()
{
this.solWriterAfterCnds = true;
if (this.parent)
this.parent.setSolWriterAfterCnds();
};
eventblockProto.is_trigger = function ()
{
if (!this.conditions.length)    // no conditions
return false;
else
return this.conditions[0].trigger;
};
eventblockProto.run = function ()
{
var i, len;
var evinfo = this.runtime.getCurrentEventStack();
evinfo.current_event = this;
for (evinfo.cndindex = 0, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
return false;                               // bail out
}
this.run_actions_and_subevents();
};
eventblockProto.run_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (evinfo.actindex = 0, len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.resume_actions_and_subevents = function ()
{
var evinfo = this.runtime.getCurrentEventStack();
var len;
for (len = this.actions.length; evinfo.actindex < len; evinfo.actindex++)
{
if (this.actions[evinfo.actindex].run())
return;
}
this.run_subevents();
};
eventblockProto.run_subevents = function ()
{
if (!this.subevents.length)
return;
var i, len, subev, pushpop;
var last = this.subevents.length - 1;
if (this.solWriterAfterCnds)
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
subev = this.subevents[i];
pushpop = (!this.group && i < last);
if (pushpop)
this.runtime.pushCopySol(subev.solModifiers);
subev.run();
if (pushpop)
this.runtime.popSol(subev.solModifiers);
else
this.runtime.clearSol(subev.solModifiers);
}
}
else
{
for (i = 0, len = this.subevents.length; i < len; i++)
{
this.subevents[i].run();
}
}
};
eventblockProto.run_pretrigger = function ()
{
var i, len;
for (i = 0, len = this.conditions.length; i < len; i++)
{
;
if (!this.conditions[i].run())  // condition failed
return false;               // bail out
}
return true;
};
eventblockProto.retrigger = function ()
{
var prevcndindex = this.runtime.getCurrentEventStack().cndindex;
var len;
var evinfo = this.runtime.pushEventStack(this);
for (evinfo.cndindex = prevcndindex + 1, len = this.conditions.length; evinfo.cndindex < len; evinfo.cndindex++)
{
if (!this.conditions[evinfo.cndindex].run())    // condition failed
{
this.runtime.popEventStack();               // moving up level of recursion
return false;                               // bail out
}
}
this.run_actions_and_subevents();
this.runtime.popEventStack();
};
cr.condition = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
this.trigger = m[3];
this.looping = m[4];
this.inverted = m[5];
this.isstatic = m[6];
if (m[0] === -1)		// system object
{
this.type = null;
this.run = this.run_system;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
if (this.isstatic)
this.run = this.run_static;
else
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
}
if (m.length === 8)
{
var i, len;
var em = m[7];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var conditionProto = cr.condition.prototype;
conditionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
conditionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return cr.xor(this.func.apply(this.runtime.system, this.results), this.inverted);
};
conditionProto.run_static = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.runtime, this.results);
};
conditionProto.run_object = function ()
{
var i, j, leni, lenj, ret, inst;
var sol = this.type.getCurrentSol();
if (sol.select_all) {
sol.instances.length = 0;       // clear contents
for (i = 0, leni = this.type.instances.length; i < leni; i++) {
inst = this.type.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted))
sol.instances.push(inst);
}
sol.select_all = false;
}
else {
var k = 0;
for (i = 0, leni = sol.instances.length; i < leni; i++) {
inst = sol.instances[i];
;
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);        // default SOL index is current object
if (this.beh_index > -1)
ret = this.func.apply(inst.behavior_insts[this.beh_index], this.results);
else
ret = this.func.apply(inst, this.results);
if (cr.xor(ret, this.inverted)) {
sol.instances[k] = inst;
k++;
}
}
sol.instances.length = k;
}
return sol.hasObjects();
};
cr.action = function (block, m)
{
this.block = block;
this.sheet = block.sheet;
this.runtime = block.runtime;
this.parameters = [];
this.results = [];
this.extra = {};		// for plugins to stow away some custom info
this.func = m[1];
;
if (m[0] === -1)	// system
{
this.type = null;
this.run = this.run_system;
}
else
{
this.type = this.runtime.types_by_index[m[0]];
;
this.run = this.run_object;
if (m[2])
{
this.behaviortype = this.type.getBehaviorByName(m[2]);
;
this.beh_index = this.type.getBehaviorIndexByName(m[2]);
;
}
else
{
this.behaviortype = null;
this.beh_index = -1;
}
}
if (m.length === 4)
{
var i, len;
var em = m[3];
for (i = 0, len = em.length; i < len; i++)
{
var param = new cr.parameter(this, em[i]);
cr.seal(param);
this.parameters.push(param);
}
this.results.length = em.length;
}
};
var actionProto = cr.action.prototype;
actionProto.postInit = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
};
actionProto.run_system = function ()
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.results[i] = this.parameters[i].get();
return this.func.apply(this.runtime.system, this.results);
};
actionProto.run_object = function ()
{
var instances = this.type.getCurrentSol().getObjects();
var i, j, leni, lenj;
for (i = 0, leni = instances.length; i < leni; i++)
{
for (j = 0, lenj = this.parameters.length; j < lenj; j++)
this.results[j] = this.parameters[j].get(i);    // pass i to use as default SOL index
if (this.beh_index > -1)
this.func.apply(instances[i].behavior_insts[this.beh_index], this.results);
else
this.func.apply(instances[i], this.results);
}
return false;
};
cr.parameter = function (owner, m)
{
this.owner = owner;
this.block = owner.block;
this.sheet = owner.sheet;
this.runtime = owner.runtime;
this.type = m[0];
switch (m[0])
{
case 0:		// number
case 1:		// string
case 7:		// any
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_exp;
this.temp = new cr.expvalue();
break;
case 5:		// layer
this.expression = new cr.expNode(this, m[1]);
this.solindex = 0;
this.get = this.get_layer;
this.temp = new cr.expvalue();
break;
case 3:		// combo
case 8:		// cmp
this.combosel = m[1];
this.get = this.get_combosel;
break;
case 6:		// layout
this.layout = this.runtime.layouts[m[1]];
;
this.get = this.get_layout;
break;
case 9:		// keyb
this.key = m[1];
this.get = this.get_key;
break;
case 4:		// object
this.object = this.runtime.types_by_index[m[1]];
;
this.get = this.get_object;
this.block.addSolModifier(this.object);
if (this.owner instanceof cr.action)
this.block.setSolWriterAfterCnds();
else if (this.block.parent)
this.block.parent.setSolWriterAfterCnds();
break;
case 10:	// instvar
this.index = m[1];
this.get = this.get_instvar;
break;
case 11:	// eventvar
this.varname = m[1];
this.eventvar = null;
this.get = this.get_eventvar;
break;
case 2:		// audiofile
this.file = m[1];
this.get = this.get_audiofile;
break;
default:
;
}
};
var parameterProto = cr.parameter.prototype;
parameterProto.postInit = function ()
{
if (this.type === 11)	// eventvar
{
this.eventvar = this.runtime.getEventVariableByName(this.varname, this.block.parent);
;
}
if (this.expression)
this.expression.postInit();
};
parameterProto.get_exp = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
return this.temp.data;      // return actual JS value, not expvalue
};
parameterProto.get_object = function ()
{
return this.object;
};
parameterProto.get_combosel = function ()
{
return this.combosel;
};
parameterProto.get_layer = function (solindex)
{
this.solindex = solindex || 0;   // default SOL index to use
this.expression.get(this.temp)
if (this.temp.is_number())
return this.runtime.getLayerByNumber(this.temp.data);
else
return this.runtime.getLayerByName(this.temp.data);
}
parameterProto.get_layout = function ()
{
return this.layout;
};
parameterProto.get_key = function ()
{
return this.key;
};
parameterProto.get_instvar = function ()
{
return this.index;
};
parameterProto.get_eventvar = function ()
{
return this.eventvar;
};
parameterProto.get_audiofile = function ()
{
return this.file;
};
cr.eventvariable = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.name = m[1];
this.vartype = m[2];
this.initial = m[3];
this.data = this.initial;
};
var eventvariableProto = cr.eventvariable.prototype;
eventvariableProto.postInit = function ()
{
};
eventvariableProto.run = function ()
{
if (this.parent)
this.data = this.initial;
};
cr.eventinclude = function (sheet, parent, m)
{
this.sheet = sheet;
this.parent = parent;
this.runtime = sheet.runtime;
this.solModifiers = [];
this.include_sheet = null;		// determined in postInit
this.include_sheet_name = m[1];
};
var eventincludeProto = cr.eventinclude.prototype;
eventincludeProto.postInit = function ()
{
this.include_sheet = this.runtime.eventsheets[this.include_sheet_name];
;
;
this.sheet.includes.add(this.include_sheet);
};
eventincludeProto.run = function ()
{
if (this.parent)
this.runtime.pushCleanSol(this.runtime.types_by_index);
if (!this.include_sheet.hasRun)
this.include_sheet.run();
if (this.parent)
this.runtime.popSol(this.runtime.types_by_index);
};
runtimeProto.testAndSelectCanvasPointOverlap = function (type, ptx, pty, inverted)
{
var sol = type.getCurrentSol();
var i, j, inst, len;
var lx, ly;
if (sol.select_all)
{
if (!inverted)
{
sol.select_all = false;
sol.instances.length = 0;   // clear contents
}
for (i = 0, len = type.instances.length; i < len; i++)
{
inst = type.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayerX(ptx);
ly = inst.layer.canvasToLayerY(pty);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
sol.instances.push(inst);
}
}
}
else
{
j = 0;
for (i = 0, len = sol.instances.length; i < len; i++)
{
inst = sol.instances[i];
inst.update_bbox();
lx = inst.layer.canvasToLayerX(ptx);
ly = inst.layer.canvasToLayerY(pty);
if (inst.contains_pt(lx, ly))
{
if (inverted)
return false;
else
{
sol.instances[j] = sol.instances[i];
j++;
}
}
}
if (!inverted)
sol.instances.length = j;
}
if (inverted)
return true;		// did not find anything overlapping
else
return sol.hasObjects();
};
runtimeProto.testOverlap = function (a, b)
{
if (!a || !b)
return false;
if (a === b)
return false;
a.update_bbox();
b.update_bbox();
if (!a.bbox.intersects_rect(b.bbox))
return false;
return a.bquad.intersects_quad(b.bquad);
};
runtimeProto.testOverlapSolid = function (inst)
{
var solid = null;
var i, len, s;
if (!cr.behaviors.solid)
return null;
for (i = 0, len = this.behaviors.length; i < len; i++)
{
if (this.behaviors[i] instanceof cr.behaviors.solid)
{
solid = this.behaviors[i];
break;
}
}
if (!solid)
return null;
var solids = solid.my_instances.values();
for (i = 0, len = solids.length; i < len; ++i)
{
s = solids[i];
if (this.testOverlap(inst, s))
return s;
}
return null;
};
runtimeProto.pushOutSolid = function (inst, xdir, ydir, dist)
{
var push_dist = dist || 50;
var oldx = inst.x
var oldy = inst.y;
var i;
var last_overlapped = null;
for (i = 0; i < push_dist; i++)
{
inst.x = Math.floor(oldx + (xdir * i));
inst.y = Math.floor(oldy + (ydir * i));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
return true;
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.pushOutSolidNearest = function (inst, max_dist_)
{
var max_dist = (typeof max_dist_ === "undefined" ? 100 : max_dist_);
var dist = 0;
var oldx = inst.x
var oldy = inst.y;
var dir = 0;
var dx = 0, dy = 0;
var last_overlapped = null;
while (dist <= max_dist)
{
switch (dir) {
case 0:		dx = 1; dy = 0; dist++; break;
case 1:		dx = 1; dy = 1; break;
case 2:		dx = 0; dy = 1; break;
case 3:		dx = -1; dy = 1; break;
case 4:		dx = -1; dy = 0; break;
case 5:		dx = -1; dy = -1; break;
case 6:		dx = 0; dy = -1; break;
case 7:		dx = 1; dy = -1; break;
}
dir = (dir + 1) % 8;
inst.x = Math.floor(oldx + (dx * dist));
inst.y = Math.floor(oldy + (dy * dist));
inst.set_bbox_changed();
if (!this.testOverlap(inst, last_overlapped))
{
last_overlapped = this.testOverlapSolid(inst);
if (!last_overlapped)
return true;
}
}
inst.x = oldx;
inst.y = oldy;
inst.set_bbox_changed();
return false;
};
runtimeProto.registerCollision = function (a, b)
{
this.registered_collisions.push([a, b]);
};
runtimeProto.checkRegisteredCollision = function (a, b)
{
var i, len, x;
for (i = 0, len = this.registered_collisions.length; i < len; i++)
{
x = this.registered_collisions[i];
if ((x[0] == a && x[1] == b) || (x[0] == b && x[1] == a))
return true;
}
return false;
};
eventSheetProto.init_trigger = function (trig)
{
;
this.runtime.triggers_to_postinit.push(trig);
var type_name;
if (trig.conditions[0].type)
type_name = trig.conditions[0].type.name;
else
type_name = "system";
if (!this.triggers[type_name])
this.triggers[type_name] = [];
var obj_entry = this.triggers[type_name];
var method = trig.conditions[0].func;
var i, len;
for (i = 0, len = obj_entry.length; i < len; i++)
{
if (obj_entry[i].method == method)
{
obj_entry[i].evs.push(trig);
return;
}
}
obj_entry.push({ method: method, evs: [trig]});
};
runtimeProto.trigger = function (method, inst)
{
;
if (!this.running_layout)
return false;
var sheet = this.running_layout.event_sheet;
if (!sheet)
return false;     // no event sheet active; nothing to trigger
return this.triggerOnSheet(method, inst, sheet, new cr.ObjectSet());
};
runtimeProto.triggerOnSheet = function (method, inst, sheet, sheetset)
{
if (sheetset.contains(sheet))
return false;
sheetset.add(sheet);
var includes = sheet.includes.values();
var ret = false;
var i, j, leni, lenj;
for (i = 0, leni = includes.length; i < leni; i++)
{
var r = this.triggerOnSheet(method, inst, includes[i], sheetset);
ret = ret || r;
}
var type_name;
if (!inst)
type_name = "system";
else
type_name = inst.type.name;
if (!sheet.triggers[type_name])
return ret;
var obj_entry = sheet.triggers[type_name];
var triggers_list = null;
for (i = 0, leni = obj_entry.length; i < leni; i++)
{
if (obj_entry[i].method == method)
{
triggers_list = obj_entry[i].evs;
break;
}
}
if (!triggers_list)
return ret;
for (i = 0, leni = triggers_list.length; i < leni; i++)
{
var trig = triggers_list[i];
this.pushCleanSol(trig.solModifiers);
if (inst)
{
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
}
var ok_to_run = true;
if (trig.parent)
{
var parents = [];
var cur_parent = trig.parent;
while (cur_parent)
{
parents.push(cur_parent);
cur_parent = cur_parent.parent;
}
parents.reverse();
for (j = 0, lenj = parents.length; j < lenj; j++)
{
if (!parents[j].run_pretrigger())   // parent event failed
{
ok_to_run = false;
break;
}
}
}
if (ok_to_run)
{
trig.run();
ret = true;     // something got triggered
}
this.popSol(trig.solModifiers);
}
return ret;             // true if anything got triggered
};
cr.eventStackFrame = function ()
{
this.reset(null);
cr.seal(this);
};
var eventStackFrameProto = cr.eventStackFrame.prototype;
eventStackFrameProto.reset = function (cur_event)
{
this.current_event = cur_event;
this.cndindex = 0;
this.actindex = 0;
};
eventStackFrameProto.isModifierAfterCnds = function ()
{
if (this.current_event.solWriterAfterCnds)
return true;
if (this.cndindex < this.current_event.conditions.length - 1)
return !!this.current_event.solModifiers.length;
return false;
};
runtimeProto.getCurrentCondition = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.conditions[evinfo.cndindex];
};
runtimeProto.getCurrentAction = function ()
{
var evinfo = this.getCurrentEventStack();
return evinfo.current_event.actions[evinfo.actindex];
};
runtimeProto.pushEventStack = function (cur_event)
{
this.event_stack_index++;
if (this.event_stack_index >= this.event_stack.length)
this.event_stack.push(new cr.eventStackFrame());
var ret = this.getCurrentEventStack();
ret.reset(cur_event);
return ret;
};
runtimeProto.popEventStack = function ()
{
;
this.event_stack_index--;
};
runtimeProto.getCurrentEventStack = function ()
{
return this.event_stack[this.event_stack_index];
};
runtimeProto.pushLoopStack = function (name_)
{
this.loop_stack_index++;
if (this.loop_stack_index >= this.loop_stack.length)
{
this.loop_stack.push(cr.seal({ name: name_, index: 0 }));
}
var ret = this.getCurrentLoop();
ret.name = name_;
ret.index = 0;
return ret;
};
runtimeProto.popLoopStack = function ()
{
;
this.loop_stack_index--;
};
runtimeProto.getCurrentLoop = function ()
{
return this.loop_stack[this.loop_stack_index];
};
runtimeProto.getEventVariableByName = function (name, scope)
{
var i, leni, j, lenj, sheet, e;
while (scope)
{
for (i = 0, leni = scope.subevents.length; i < leni; i++)
{
e = scope.subevents[i];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
scope = scope.parent;
}
for (i = 0, leni = this.eventsheets_by_index.length; i < leni; i++)
{
sheet = this.eventsheets_by_index[i];
for (j = 0, lenj = sheet.events.length; j < lenj; j++)
{
e = sheet.events[j];
if (e instanceof cr.eventvariable && name.toLowerCase() === e.name.toLowerCase())
return e;
}
}
return null;
};
}());
(function()
{
cr.expNode = function (owner_, m)
{
this.owner = owner_;
this.runtime = owner_.runtime;
this.type = m[0];
;
this.get = [this.eval_int,
this.eval_float,
this.eval_string,
this.eval_unaryminus,
this.eval_add,
this.eval_subtract,
this.eval_multiply,
this.eval_divide,
this.eval_mod,
this.eval_power,
this.eval_and,
this.eval_or,
this.eval_equal,
this.eval_notequal,
this.eval_less,
this.eval_lessequal,
this.eval_greater,
this.eval_greaterequal,
this.eval_conditional,
this.eval_system_exp,
this.eval_object_behavior_exp,
this.eval_instvar_exp,
this.eval_object_behavior_exp,
this.eval_eventvar_exp][this.type];
var paramsModel = null;
this.temp = new cr.expvalue();
switch (this.type) {
case 0:		// int
case 1:		// float
case 2:		// string
this.value = m[1];
break;
case 3:		// unaryminus
this.first = new cr.expNode(owner_, m[1]);
break;
case 18:	// conditional
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
this.third = new cr.expNode(owner_, m[3]);
break;
case 19:	// system_exp
this.func = m[1];
;
this.results = [];
this.parameters = [];
if (m.length === 3)
{
paramsModel = m[2];
this.results.length = paramsModel.length + 1;	// must also fit 'ret'
}
else
this.results.length = 1;      // to fit 'ret'
break;
case 20:	// object_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.beh_index = -1;
this.func = m[2];
if (m[3])
this.instance_expr = new cr.expNode(owner_, m[3]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 5)
{
paramsModel = m[4];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 21:		// instvar_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
if (m[2])
this.instance_expr = new cr.expNode(owner_, m[2]);
else
this.instance_expr = null;
this.varindex = m[3];
break;
case 22:		// behavior_exp
this.object_type = this.runtime.types_by_index[m[1]];
;
this.behavior_type = this.object_type.getBehaviorByName(m[2]);
;
this.beh_index = this.object_type.getBehaviorIndexByName(m[2]);
this.func = m[3];
if (m[4])
this.instance_expr = new cr.expNode(owner_, m[4]);
else
this.instance_expr = null;
this.results = [];
this.parameters = [];
if (m.length === 6)
{
paramsModel = m[5];
this.results.length = paramsModel.length + 1;
}
else
this.results.length = 1;	// to fit 'ret'
break;
case 23:		// eventvar_exp
this.varname = m[1];
this.eventvar = null;	// assigned in postInit
break;
}
if (this.type >= 4 && this.type <= 17)
{
this.first = new cr.expNode(owner_, m[1]);
this.second = new cr.expNode(owner_, m[2]);
}
if (paramsModel)
{
var i, len;
for (i = 0, len = paramsModel.length; i < len; i++)
this.parameters.push(new cr.expNode(owner_, paramsModel[i]));
}
cr.seal(this);
};
var expNodeProto = cr.expNode.prototype;
expNodeProto.postInit = function ()
{
if (this.type === 23)	// eventvar_exp
{
this.eventvar = this.owner.runtime.getEventVariableByName(this.varname, this.owner.block.parent);
;
}
if (this.first)
this.first.postInit();
if (this.second)
this.second.postInit();
if (this.third)
this.third.postInit();
if (this.instance_expr)
this.instance_expr.postInit();
if (this.parameters)
{
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
this.parameters[i].postInit();
}
};
expNodeProto.eval_system_exp = function (ret)
{
this.results[0] = ret;
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++)
{
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
this.func.apply(this.runtime.system, this.results);
};
expNodeProto.eval_object_behavior_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length) {
ret.set_int(0);
return;
}
this.results[0] = ret;
var i, len;
for (i = 0, len = this.parameters.length; i < len; i++) {
this.parameters[i].get(this.temp);
this.results[i + 1] = this.temp.data;   // passing actual javascript value as argument instead of expvalue
}
var index = this.owner.solindex;
if (this.instance_expr) {
this.instance_expr.get(this.temp);
if (this.temp.is_number()) {
index = this.temp.data;
instances = this.object_type.instances;    // pick from all instances, not SOL
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var returned_val;
if (this.beh_index > -1)
returned_val = this.func.apply(instances[index].behavior_insts[this.beh_index], this.results);
else
returned_val = this.func.apply(instances[index], this.results);
;
};
expNodeProto.eval_instvar_exp = function (ret)
{
var sol = this.object_type.getCurrentSol();
var instances = sol.getObjects();
if (!instances.length)
{
ret.set_int(0);
return;
}
var index = this.owner.solindex;
if (this.instance_expr)
{
this.instance_expr.get(this.temp);
if (this.temp.is_number())
{
index = this.temp.data;
var type_instances = this.object_type.instances;
index %= type_instances.length;     // wraparound
if (index < 0)                      // offset
index += type_instances.length;
var to_ret = type_instances[index].instance_vars[this.varindex];
if (typeof to_ret === "string")
ret.set_string(to_ret);
else
ret.set_float(to_ret);
return;         // done
}
}
index %= instances.length;      // wraparound
if (index < 0)
index += instances.length;
var to_ret = instances[index].instance_vars[this.varindex];
if (typeof to_ret === "string")
ret.set_string(to_ret);
else
ret.set_float(to_ret);
};
expNodeProto.eval_int = function (ret)
{
ret.type = cr.exptype.Integer;
ret.data = this.value;
};
expNodeProto.eval_float = function (ret)
{
ret.type = cr.exptype.Float;
ret.data = this.value;
};
expNodeProto.eval_string = function (ret)
{
ret.type = cr.exptype.String;
ret.data = this.value;
};
expNodeProto.eval_unaryminus = function (ret)
{
this.first.get(ret);                // retrieve operand
if (ret.is_number())
ret.data = -ret.data;
};
expNodeProto.eval_add = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data += this.temp.data;          // both operands numbers: add
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_subtract = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data -= this.temp.data;          // both operands numbers: subtract
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_multiply = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data *= this.temp.data;          // both operands numbers: multiply
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_divide = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data /= this.temp.data;          // both operands numbers: divide
ret.make_float();
}
};
expNodeProto.eval_mod = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data %= this.temp.data;          // both operands numbers: modulo
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_power = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
ret.data = Math.pow(ret.data, this.temp.data);   // both operands numbers: raise to power
if (this.temp.is_float())
ret.make_float();
}
};
expNodeProto.eval_and = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number())
{
if (this.temp.is_string())
{
ret.set_string(ret.data.toString() + this.temp.data);
}
else
{
if (ret.data && this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
}
else if (ret.is_string())
{
ret.data += this.temp.data.toString();
}
};
expNodeProto.eval_or = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
if (ret.is_number() && this.temp.is_number())
{
if (ret.data || this.temp.data)
ret.set_int(1);
else
ret.set_int(0);
}
};
expNodeProto.eval_conditional = function (ret)
{
this.first.get(ret);                // condition operand
if (ret.data)                       // is true
this.second.get(ret);           // evaluate second operand to ret
else
this.third.get(ret);            // evaluate third operand to ret
};
expNodeProto.eval_equal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data === this.temp.data ? 1 : 0);
};
expNodeProto.eval_notequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data !== this.temp.data ? 1 : 0);
};
expNodeProto.eval_less = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data < this.temp.data ? 1 : 0);
};
expNodeProto.eval_lessequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data <= this.temp.data ? 1 : 0);
};
expNodeProto.eval_greater = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data > this.temp.data ? 1 : 0);
};
expNodeProto.eval_greaterequal = function (ret)
{
this.first.get(ret);                // left operand
this.second.get(this.temp);			// right operand
ret.set_int(ret.data >= this.temp.data ? 1 : 0);
};
expNodeProto.eval_eventvar_exp = function (ret)
{
if (typeof this.eventvar.data === "number")
ret.set_float(this.eventvar.data);
else
ret.set_string(this.eventvar.data);
};
cr.expvalue = function (type, data)
{
this.type = type || cr.exptype.Integer;
this.data = data || 0;
;
;
;
if (this.type == cr.exptype.Integer)
this.data = Math.floor(this.data);
cr.seal(this);
};
var expvalueProto = cr.expvalue.prototype;
expvalueProto.is_int = function ()
{
return this.type === cr.exptype.Integer;
};
expvalueProto.is_float = function ()
{
return this.type === cr.exptype.Float;
};
expvalueProto.is_number = function ()
{
return this.type === cr.exptype.Integer || this.type === cr.exptype.Float;
};
expvalueProto.is_string = function ()
{
return this.type === cr.exptype.String;
};
expvalueProto.make_int = function ()
{
if (!this.is_int())
{
if (this.is_float())
this.data = Math.floor(this.data);      // truncate float
else if (this.is_string())
this.data = parseInt(this.data, 10);
this.type = cr.exptype.Integer;
}
};
expvalueProto.make_float = function ()
{
if (!this.is_float())
{
if (this.is_string())
this.data = parseFloat(this.data);
this.type = cr.exptype.Float;
}
};
expvalueProto.make_string = function ()
{
if (!this.is_string())
{
this.data = this.data.toString();
this.type = cr.exptype.String;
}
};
expvalueProto.set_int = function (val)
{
;
this.type = cr.exptype.Integer;
this.data = Math.floor(val);
};
expvalueProto.set_float = function (val)
{
;
this.type = cr.exptype.Float;
this.data = val;
};
expvalueProto.set_string = function (val)
{
;
this.type = cr.exptype.String;
this.data = val;
};
expvalueProto.set_any = function (val)
{
if (typeof val === "number")
{
this.type = cr.exptype.Float;
this.data = val;
}
else if (typeof val === "string")
{
this.type = cr.exptype.String;
this.data = val.toString();
}
else
{
this.type = cr.exptype.Integer;
this.data = 0;
}
};
cr.exptype = {
Integer: 0,     // emulated; no native integer support in javascript
Float: 1,
String: 2
};
}());
;
cr.system_object = function (runtime)
{
this.runtime = runtime;
this.waits = [];
};
(function ()
{
var sysProto = cr.system_object.prototype;
sysProto.cnds = {};
sysProto.acts = {};
sysProto.exps = {};
var syscnds = sysProto.cnds;
syscnds.EveryTick = function()
{
return true;
};
syscnds.OnLayoutStart = function()
{
return true;
};
syscnds.OnLayoutEnd = function()
{
return true;
};
syscnds.Compare = function(x, cmp, y)
{
return cr.do_cmp(x, cmp, y);
};
syscnds.CompareTime = function (cmp, t)
{
var elapsed = this.runtime.kahanTime.sum;
if (cmp === 0)
{
var cnd = this.runtime.getCurrentCondition();
if (!cnd.extra.CompareTime_executed)
{
if (elapsed >= t)
{
cnd.extra.CompareTime_executed = true;
return true;
}
}
return false;
}
return cr.do_cmp(elapsed, cmp, t);
};
syscnds.LayerVisible = function (layer)
{
if (!layer)
return false;
else
return layer.visible;
};
syscnds.LayerCmpOpacity = function (layer, cmp, opacity_)
{
if (!layer)
return false;
return cr.do_cmp(layer.opacity * 100, cmp, opacity_);
};
syscnds.Repeat = function (count)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack();
var i;
if (solModifierAfterCnds)
{
for (i = 0; i < count; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = 0; i < count; i++)
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.For = function (name, start, end)
{
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i;
if (solModifierAfterCnds)
{
for (i = start; i <= end; i++)  // inclusive to end
{
this.runtime.pushCopySol(current_event.solModifiers);
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
for (i = start; i <= end; i++)  // inclusive to end
{
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.ForEach = function (obj)
{
var sol = obj.getCurrentSol();
var instances = sol.getObjects().slice(0);
var current_frame = this.runtime.getCurrentEventStack();
var current_event = current_frame.current_event;
var solModifierAfterCnds = current_frame.isModifierAfterCnds();
var current_loop = this.runtime.pushLoopStack(name);
var i, len;
if (solModifierAfterCnds)
{
for (i = 0, len = instances.length; i < len; i++)
{
this.runtime.pushCopySol(current_event.solModifiers);
sol = obj.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
this.runtime.popSol(current_event.solModifiers);
}
}
else
{
sol.select_all = false;
sol.instances.length = 1;
for (i = 0, len = instances.length; i < len; i++)
{
sol.instances[0] = instances[i];
current_loop.index = i;
current_event.retrigger();
}
}
this.runtime.popLoopStack();
return false;
};
syscnds.TriggerOnce = function ()
{
var cnd = this.runtime.getCurrentCondition();
var last_tick = cnd.extra.TriggerOnce_lastTick || 0;
var cur_tick = this.runtime.tickcount;
cnd.extra.TriggerOnce_lastTick = cur_tick;
return this.runtime.layout_first_tick || !(last_tick === cur_tick - 1);
};
syscnds.Every = function (seconds)
{
var cnd = this.runtime.getCurrentCondition();
var last_time = cnd.extra.Every_lastTime || 0;
var cur_time = this.runtime.kahanTime.sum;
if (cur_time >= last_time + seconds)
{
cnd.extra.Every_lastTime = cur_time;
return true;
}
else
return false;
};
syscnds.PickNth = function (obj, index)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
index = Math.floor(index);
if (index < 0 || index >= instances.length)
return false;
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = instances[index];
return true;
};
syscnds.PickRandom = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var index = Math.floor(Math.random() * instances.length);
if (index >= instances.length)
return false;
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = instances[index];
return true;
};
syscnds.CompareVar = function (v, cmp, val)
{
return cr.do_cmp(v.data, cmp, val);
};
syscnds.IsGroupActive = function (group)
{
return this.runtime.activeGroups.hasOwnProperty(group);
};
var sysacts = sysProto.acts;
sysacts.GoToLayout = function(to)
{
;
this.runtime.changelayout = to;
};
sysacts.CreateObject = function (obj, layer, x, y)
{
if (!layer || !obj)
return;
var inst = this.runtime.createInstance(obj, layer);
if (obj.plugin.is_world)
{
inst.x = x;
inst.y = y;
}
var sol = inst.type.getCurrentSol();
sol.select_all = false;
sol.instances.length = 1;
sol.instances[0] = inst;
};
sysacts.SetLayerVisible = function (layer, visible)
{
if (!layer)
return;
layer.visible = visible;
this.runtime.redraw = true;
};
sysacts.SetLayerOpacity = function (layer, opacity_)
{
if (!layer)
return;
opacity_ = cr.clamp(opacity_ / 100, 0, 1);
if (layer.opacity != opacity_)
{
layer.opacity = opacity_;
this.runtime.redraw = true;
}
};
sysacts.ScrollX = function(x)
{
this.runtime.running_layout.scrollToX(x);
};
sysacts.ScrollY = function(y)
{
this.runtime.running_layout.scrollToY(y);
};
sysacts.Scroll = function(x, y)
{
this.runtime.running_layout.scrollToX(x);
this.runtime.running_layout.scrollToY(y);
};
sysacts.ScrollToObject = function(obj)
{
var inst = obj.getFirstPicked();
if (inst)
{
this.runtime.running_layout.scrollToX(inst.x);
this.runtime.running_layout.scrollToY(inst.y);
}
};
sysacts.SetVar = function(v, x)
{
if (v.vartype === 0)
{
if (typeof x === "number")
v.data = x;
else
v.data = parseFloat(x);
}
else if (v.vartype === 1)
v.data = x.toString();
};
sysacts.AddVar = function(v, x)
{
if (v.vartype === 0)
{
if (typeof x === "number")
v.data += x;
else
v.data += parseFloat(x);
}
else if (v.vartype === 1)
v.data += x.toString();
};
sysacts.SubVar = function(v, x)
{
if (v.vartype === 0)
{
if (typeof x === "number")
v.data -= x;
else
v.data -= parseFloat(x);
}
};
sysacts.SetGroupActive = function (group, active)
{
var activeGroups = this.runtime.activeGroups;
switch (active) {
case 0:
delete activeGroups[group];
break;
case 1:
activeGroups[group] = true;
break;
case 2:
if (activeGroups[group])
delete activeGroups[group];
else
activeGroups[group] = true;
break;
}
};
sysacts.SetTimescale = function (ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
this.runtime.timescale = ts;
};
sysacts.SetObjectTimescale = function (obj, ts_)
{
var ts = ts_;
if (ts < 0)
ts = 0;
if (!obj)
return;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = ts;
}
};
sysacts.RestoreObjectTimescale = function (obj)
{
if (!obj)
return false;
var sol = obj.getCurrentSol();
var instances = sol.getObjects();
var i, len;
for (i = 0, len = instances.length; i < len; i++)
{
instances[i].my_timescale = -1.0;
}
};
sysacts.Wait = function (seconds)
{
if (seconds < 0)
return;
var i, len, s, t;
var evinfo = this.runtime.getCurrentEventStack();
var waitobj = {};
waitobj.time = this.runtime.kahanTime.sum + seconds;
waitobj.ev = evinfo.current_event;
waitobj.actindex = evinfo.actindex + 1;	// pointing at next action
waitobj.deleteme = false;
waitobj.sols = {};
waitobj.solModifiers = [];
for (i = 0, len = this.runtime.types_by_index.length; i < len; i++)
{
t = this.runtime.types_by_index[i];
s = t.getCurrentSol();
if (s.select_all)
continue;
waitobj.solModifiers.push(t);
waitobj.sols[i.toString()] = s.instances.slice(0);
}
this.waits.push(waitobj);
return true;
};
sysacts.SetLayerScale = function (layer, scale)
{
if (!layer)
return;
layer.scale = scale;
this.runtime.redraw = true;
};
var sysexps = sysProto.exps;
sysexps["int"] = function(ret, x)
{
if (typeof x === "string")
{
ret.set_int(parseInt(x, 10));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_int(x);
};
sysexps["float"] = function(ret, x)
{
if (typeof x === "string")
{
ret.set_float(parseFloat(x));
if (isNaN(ret.data))
ret.data = 0;
}
else
ret.set_float(x);
};
sysexps.str = function(ret, x)
{
if (typeof x === "string")
ret.set_string(x);
else
ret.set_string(x.toString());
};
sysexps.len = function(ret, x)
{
ret.set_int(x.length);
};
sysexps.random = function (ret, a, b)
{
if (b === undefined)
{
ret.set_float(Math.random() * a);
}
else
{
ret.set_float(Math.random() * (b - a) + a);
}
};
sysexps.sqrt = function(ret, x)
{
ret.set_float(Math.sqrt(x));
};
sysexps.abs = function(ret, x)
{
ret.set_float(Math.abs(x));
};
sysexps.round = function(ret, x)
{
ret.set_int(Math.round(x));
};
sysexps.floor = function(ret, x)
{
ret.set_int(Math.floor(x));
};
sysexps.ceil = function(ret, x)
{
ret.set_int(Math.ceil(x));
};
sysexps.sin = function(ret, x)
{
ret.set_float(Math.sin(cr.to_radians(x)));
};
sysexps.cos = function(ret, x)
{
ret.set_float(Math.cos(cr.to_radians(x)));
};
sysexps.tan = function(ret, x)
{
ret.set_float(Math.tan(cr.to_radians(x)));
};
sysexps.asin = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.asin(x)));
};
sysexps.acos = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.acos(x)));
};
sysexps.atan = function(ret, x)
{
ret.set_float(cr.to_degrees(Math.atan(x)));
};
sysexps.exp = function(ret, x)
{
ret.set_float(Math.exp(x));
};
sysexps.ln = function(ret, x)
{
ret.set_float(Math.log(x));
};
sysexps.log10 = function(ret, x)
{
ret.set_float(Math.log(x) / Math.LN10);
};
sysexps.max = function(ret)
{
var max_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (max_ < arguments[i])
max_ = arguments[i];
}
ret.set_float(max_);
};
sysexps.min = function(ret)
{
var min_ = arguments[1];
var i, len;
for (i = 2, len = arguments.length; i < len; i++)
{
if (min_ > arguments[i])
min_ = arguments[i];
}
ret.set_float(min_);
};
sysexps.dt = function(ret)
{
ret.set_float(this.runtime.dt);
};
sysexps.timescale = function(ret)
{
ret.set_float(this.runtime.timescale);
};
sysexps.wallclocktime = function(ret)
{
ret.set_float((Date.now() - this.runtime.start_time) / 1000.0);
};
sysexps.time = function(ret)
{
ret.set_float(this.runtime.kahanTime.sum);
};
sysexps.tickcount = function(ret)
{
ret.set_int(this.runtime.tickcount);
};
sysexps.objectcount = function(ret)
{
ret.set_int(this.runtime.objectcount);
};
sysexps.fps = function(ret)
{
ret.set_int(this.runtime.fps);
};
sysexps.loopindex = function(ret, name_)
{
if (!this.runtime.loop_stack.length)
{
ret.set_int(0);
return;
}
if (name_)
{
var i, len;
for (i = 0, len = this.runtime.loop_stack.length; i < len; i++)
{
var loop = this.runtime.loop_stack[i];
if (loop.name === name_)
{
ret.set_int(loop.index);
return;
}
}
ret.set_int(0);
}
else
{
ret.set_int(this.runtime.getCurrentLoop().index);
}
};
sysexps.distance = function(ret, x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
ret.set_float(Math.sqrt((dx * dx) + (dy * dy)));
};
sysexps.angle = function(ret, x1, y1, x2, y2)
{
var dx = x2 - x1;
var dy = y2 - y1;
ret.set_float(cr.to_degrees(Math.atan2(dy, dx)));
};
sysexps.scrollx = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollX);
};
sysexps.scrolly = function(ret)
{
ret.set_float(this.runtime.running_layout.scrollY);
};
sysexps.newline = function(ret)
{
ret.set_string("\n");
};
sysexps.lerp = function(ret, a, b, x)
{
ret.set_float(cr.lerp(a, b, x));
};
sysexps.windowwidth = function(ret)
{
ret.set_int(this.runtime.width);
};
sysexps.windowheight = function(ret)
{
ret.set_int(this.runtime.height);
};
sysexps.uppercase = function(ret, str)
{
ret.set_string(str.toUpperCase());
};
sysexps.lowercase = function(ret, str)
{
ret.set_string(str.toLowerCase());
};
sysexps.clamp = function(ret, x, l, u)
{
if (x < l)
ret.set_float(l);
else if (x > u)
ret.set_float(u);
else
ret.set_float(x);
};
sysexps.layerscale = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.scale);
};
sysexps.layeropacity = function (ret, layerparam)
{
var layer = this.runtime.getLayer(layerparam);
if (!layer)
ret.set_float(0);
else
ret.set_float(layer.opacity * 100);
};
sysexps.layoutwidth = function (ret)
{
ret.set_int(this.runtime.running_layout.width);
};
sysexps.layoutheight = function (ret)
{
ret.set_int(this.runtime.running_layout.height);
};
sysexps.find = function (ret, text, searchstr)
{
ret.set_int(text.search(new RegExp(cr.regexp_escape(searchstr), "i")));
};
sysexps.left = function (ret, text, n)
{
ret.set_string(text.substr(0, n));
};
sysexps.right = function (ret, text, n)
{
ret.set_string(text.substr(text.length - n));
};
sysexps.mid = function (ret, text, index_, length_)
{
ret.set_string(text.substr(index_, length_));
};
sysexps.tokenat = function (ret, text, index_, sep)
{
var arr = text.split(sep);
var i = Math.floor(index_);
if (i < 0 || i >= arr.length)
ret.set_string("");
else
ret.set_string(arr[i]);
};
sysexps.tokencount = function (ret, text, sep)
{
ret.set_int(text.split(sep).length);
};
sysexps.replace = function (ret, text, find_, replace_)
{
ret.set_string(text.replace(new RegExp(cr.regexp_escape(find_), "gi"), replace_));
};
sysexps.trim = function (ret, text)
{
ret.set_string(text.trim());
};
sysexps.pi = function (ret)
{
ret.set_float(Math.PI);
};
sysProto.runWaits = function ()
{
var i, j, len, w, k, s;
var evinfo = this.runtime.getCurrentEventStack();
for (i = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
if (w.time > this.runtime.kahanTime.sum)
continue;
evinfo.current_event = w.ev;
evinfo.actindex = w.actindex;
evinfo.cndindex = 0;
for (k in w.sols)
{
if (w.sols.hasOwnProperty(k))
{
s = this.runtime.types_by_index[parseInt(k, 10)].getCurrentSol();
s.select_all = false;
s.instances = w.sols[k];
}
}
w.ev.resume_actions_and_subevents();
this.runtime.clearSol(w.solModifiers);
w.deleteme = true;
}
for (i = 0, j = 0, len = this.waits.length; i < len; i++)
{
w = this.waits[i];
this.waits[j] = w;
if (!w.deleteme)
j++;
}
this.waits.length = j;
};
}());
;
cr.add_common_aces = function (m)
{
var pluginProto = m[0].prototype;	
var singleglobal = m[1];
var is_world = m[2];
var position_aces = m[3];
var size_aces = m[4];
var angle_aces = m[5];
var appearance_aces = m[6];
var zorder_aces = m[7];
if (!pluginProto.cnds)
pluginProto.cnds = {};
if (!pluginProto.acts)
pluginProto.acts = {};
if (!pluginProto.exps)
pluginProto.exps = {};
var cnds = pluginProto.cnds;
var acts = pluginProto.acts;
var exps = pluginProto.exps;
if (position_aces)
{
cnds.CompareX = function (cmp, x)
{
return cr.do_cmp(this.x, cmp, x);
};
cnds.CompareY = function (cmp, y)
{
return cr.do_cmp(this.y, cmp, y);
};
cnds.IsOnScreen = function ()
{
var layer = this.layer;
if (!this.visible || !layer.visible)
return false;
this.update_bbox();
var bbox = this.bbox;
return !(bbox.right < layer.viewLeft || bbox.bottom < layer.viewTop || bbox.left > layer.viewRight || bbox.top > layer.viewBottom);
};
cnds.IsOutsideLayout = function ()
{
this.update_bbox();
var bbox = this.bbox;
var layout = this.runtime.running_layout;
return (bbox.right < 0 || bbox.bottom < 0 || bbox.left > layout.width || bbox.top > layout.height);
};
acts.SetX = function (x)
{
if (this.x !== x)
{
this.x = x;
this.set_bbox_changed();
}
};
acts.SetY = function (y)
{
if (this.y !== y)
{
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPos = function (x, y)
{
if (this.x !== x || this.y !== y)
{
this.x = x;
this.y = y;
this.set_bbox_changed();
}
};
acts.SetPosToObject = function (obj, imgpt)
{
var inst = obj.getPairedInstance(this);
if (inst && (this.x !== inst.x || this.y !== inst.y))
{
this.x = inst.x;
this.y = inst.y;
this.set_bbox_changed();
}
};
acts.MoveForward = function (dist)
{
if (dist !== 0)
{
this.x += Math.cos(this.angle) * dist;
this.y += Math.sin(this.angle) * dist;
this.set_bbox_changed();
}
};
acts.MoveAtAngle = function (a, dist)
{
if (dist !== 0)
{
this.x += Math.cos(cr.to_radians(a)) * dist;
this.y += Math.sin(cr.to_radians(a)) * dist;
this.set_bbox_changed();
}
};
exps.X = function (ret)
{
ret.set_float(this.x);
};
exps.Y = function (ret)
{
ret.set_float(this.y);
};
exps.dt = function (ret)
{
ret.set_float(this.runtime.getDt(this));
};
}
if (size_aces)
{
cnds.CompareWidth = function (cmp, w)
{
return cr.do_cmp(this.width, cmp, w);
};
cnds.CompareHeight = function (cmp, h)
{
return cr.do_cmp(this.height, cmp, h);
};
acts.SetWidth = function (w)
{
var newwidth = w;
if (newwidth < 0)
newwidth = -newwidth;
if (this.width !== newwidth)
{
this.width = newwidth;
this.set_bbox_changed();
}
};
acts.SetHeight = function (h)
{
var newheight = h;
if (newheight < 0)
newheight = -newheight;
if (this.height !== newheight)
{
this.height = newheight;
this.set_bbox_changed();
}
};
acts.SetSize = function (w, h)
{
var newwidth = w;
var newheight = h;
if (newwidth < 0)
newwidth = -newwidth;
if (newheight < 0)
newheight = -newheight;
if (this.width !== newwidth || this.height !== newheight)
{
this.width = newwidth;
this.height = newheight;
this.set_bbox_changed();
}
};
exps.Width = function (ret)
{
ret.set_float(this.width);
};
exps.Height = function (ret)
{
ret.set_float(this.height);
};
}
if (angle_aces)
{
cnds.AngleWithin = function (within, a)
{
return cr.angleDiff(this.angle, cr.to_radians(a)) <= cr.to_radians(within);
};
cnds.IsClockwiseFrom = function (a)
{
return cr.angleClockwise(this.angle, cr.to_radians(a));
};
cnds.IsBetweenAngles = function (a, b)
{
var lower = cr.to_clamped_radians(a);
var upper = cr.to_clamped_radians(b);
var angle = cr.clamp_angle(this.angle);
return cr.angleClockwise(angle, lower) && !cr.angleClockwise(angle, upper);
};
acts.SetAngle = function (a)
{
var newangle = cr.to_radians(cr.clamp_angle_degrees(a));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateClockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle += cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateCounterclockwise = function (a)
{
if (a !== 0 && !isNaN(a))
{
this.angle -= cr.to_radians(a);
this.angle = cr.clamp_angle(this.angle);
this.set_bbox_changed();
}
};
acts.RotateTowardAngle = function (amt, target)
{
var newangle = cr.angleRotate(this.angle, cr.to_radians(target), cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.RotateTowardPosition = function (amt, x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var target = Math.atan2(dy, dx);
var newangle = cr.angleRotate(this.angle, target, cr.to_radians(amt));
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
acts.SetTowardPosition = function (x, y)
{
var dx = x - this.x;
var dy = y - this.y;
var newangle = Math.atan2(dy, dx);
if (isNaN(newangle))
return;
if (this.angle !== newangle)
{
this.angle = newangle;
this.set_bbox_changed();
}
};
exps.Angle = function (ret)
{
ret.set_float(cr.to_clamped_degrees(this.angle));
};
}
if (!singleglobal)
{
cnds.CompareInstanceVar = function (iv, cmp, val)
{
return cr.do_cmp(this.instance_vars[iv], cmp, val);
};
cnds.IsBoolInstanceVarSet = function (iv)
{
return this.instance_vars[iv];
};
cnds.PickByUID = function (u)
{
return this.uid === u;
};
acts.SetInstanceVar = function (iv, val)
{
if (typeof this.instance_vars[iv] === "number")
{
if (typeof val === "number")
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = parseFloat(val);
}
else if (typeof this.instance_vars[iv] === "string")
{
if (typeof val === "string")
this.instance_vars[iv] = val;
else
this.instance_vars[iv] = val.toString();
}
else
;
};
acts.AddInstanceVar = function (iv, val)
{
if (typeof this.instance_vars[iv] === "number")
{
if (typeof val === "number")
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += parseFloat(val);
}
else if (typeof this.instance_vars[iv] === "string")
{
if (typeof val === "string")
this.instance_vars[iv] += val;
else
this.instance_vars[iv] += val.toString();
}
else
;
};
acts.SubInstanceVar = function (iv, val)
{
if (typeof this.instance_vars[iv] === "number")
{
if (typeof val === "number")
this.instance_vars[iv] -= val;
else
this.instance_vars[iv] -= parseFloat(val);
}
else
;
};
acts.SetBoolInstanceVar = function (iv, val)
{
this.instance_vars[iv] = val;
};
acts.ToggleBoolInstanceVar = function (iv)
{
this.instance_vars[iv] = !this.instance_vars[iv];
};
acts.Destroy = function ()
{
this.runtime.DestroyInstance(this);
};
exps.Count = function (ret)
{
ret.set_int(this.type.instances.length);
};
exps.UID = function (ret)
{
ret.set_int(this.uid);
};
}
if (appearance_aces)
{
cnds.IsVisible = function ()
{
return this.visible;
};
acts.SetVisible = function (v)
{
if (!v !== !this.visible)
{
this.visible = v;
this.runtime.redraw = true;
}
};
cnds.CompareOpacity = function (cmp, x)
{
return cr.do_cmp(this.opacity * 100, cmp, x);
};
acts.SetOpacity = function (x)
{
var new_opacity = x / 100.0;
if (new_opacity < 0)
new_opacity = 0;
else if (new_opacity > 1)
new_opacity = 1;
if (new_opacity !== this.opacity)
{
this.opacity = new_opacity;
this.runtime.redraw = true;
}
};
exps.Opacity = function (ret)
{
ret.set_float(this.opacity * 100.0);
};
}
if (zorder_aces)
{
acts.MoveToTop = function ()
{
var zindex = this.get_zindex();
if (zindex === this.layer.instances.length - 1)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.push(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToBottom = function ()
{
var zindex = this.get_zindex();
if (zindex === 0)
return;
cr.arrayRemove(this.layer.instances, zindex);
this.layer.instances.unshift(this);
this.runtime.redraw = true;
this.layer.zindices_stale = true;
};
acts.MoveToLayer = function (layerMove)
{
if (!layerMove || layerMove == this.layer)
return;
cr.arrayRemove(this.layer.instances, this.get_zindex());
this.layer.zindices_stale = true;
this.layer = layerMove;
this.zindex = layerMove.instances.length;
layerMove.instances.push(this);
this.runtime.redraw = true;
};
exps.LayerNumber = function (ret)
{
ret.set_int(this.layer.number);
};
exps.LayerName = function (ret)
{
ret.set_string(this.layer.name);
};
exps.ZIndex = function (ret)
{
ret.set_int(this.get_zindex());
};
}
};
cr.set_bbox_changed = function ()
{
this.bbox_changed = true;       // will recreate next time box requested
this.runtime.redraw = true;     // assume runtime needs to redraw
var i, len;
for (i = 0, len = this.bbox_changed_callbacks.length; i < len; i++)
{
this.bbox_changed_callbacks[i](this);
}
};
cr.add_bbox_changed_callback = function (f)
{
if (f)
this.bbox_changed_callbacks.push(f);
};
cr.update_bbox = function ()
{
if (!this.bbox_changed)
return;                 // bounding box not changed
this.bbox.set(this.x, this.y, this.x + this.width, this.y + this.height);
this.bbox.offset(-this.hotspotX * this.width, -this.hotspotY * this.height);
if (!this.angle || this.angle === 0)
{
this.bquad.set_from_rect(this.bbox);    // make bounding quad from box
}
else
{
this.bbox.offset(-this.x, -this.y);       					// translate to origin
this.bquad.set_from_rotated_rect(this.bbox, this.angle);	// rotate around origin
this.bquad.offset(this.x, this.y);      					// translate back to original position
this.bquad.bounding_box(this.bbox);
}
this.bbox_changed = false;  // bounding box up to date
};
cr.inst_contains_pt = function (x, y)
{
if (!this.bbox.contains_pt(x, y))
return false;
else
return this.bquad.contains_pt(x, y);
};
cr.inst_get_iid = function ()
{
this.type.updateIIDs();
return this.iid;
};
cr.inst_get_zindex = function ()
{
this.layer.updateZIndices();
return this.zindex;
};
cr.inst_toString = function ()
{
return "inst:" + this.type.name + "#" + this.uid;
};
cr.type_getFirstPicked = function ()
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[0];
else
return null;
};
cr.type_getPairedInstance = function (inst)
{
var instances = this.getCurrentSol().getObjects();
if (instances.length)
return instances[inst.get_iid() % instances.length];
else
return null;
};
cr.type_updateIIDs = function ()
{
if (!this.stale_iids)
return;		// up to date
var i, len;
for (i = 0, len = this.instances.length; i < len; i++)
this.instances[i].iid = i;
this.stale_iids = false;
};
cr.type_getCurrentSol = function ()
{
return this.solstack[this.cur_sol];
};
cr.type_pushCleanSol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
else
this.solstack[this.cur_sol].select_all = true;  // else clear next SOL
};
cr.type_pushCopySol = function ()
{
this.cur_sol++;
if (this.cur_sol === this.solstack.length)
this.solstack.push(new cr.selection(this));
var clonesol = this.solstack[this.cur_sol];
var prevsol = this.solstack[this.cur_sol - 1];
if (prevsol.select_all)
clonesol.select_all = true;
else
{
clonesol.select_all = false;
clonesol.instances = prevsol.instances.slice(0);    // copy elements
}
};
cr.type_popSol = function ()
{
;
this.cur_sol--;
};
cr.type_getBehaviorByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return this.behaviors[i];
}
return null;
};
cr.type_getBehaviorIndexByName = function (behname) {
var i, len;
for (i = 0, len = this.behaviors.length; i < len; i++) {
if (behname === this.behaviors[i].name)
return i;
}
return -1;
};
cr.do_cmp = function (x, cmp, y)
{
switch (cmp)
{
case 0:     // equal
return x === y;
case 1:     // not equal
return x !== y;
case 2:     // less
return x < y;
case 3:     // less/equal
return x <= y;
case 4:     // greater
return x > y;
case 5:     // greater/equal
return x >= y;
default:
;
return false;
}
};
;
;
cr.plugins_.Function = function(runtime)
{
this.runtime = runtime;
};
(function()
{
var pluginProto = cr.plugins_.Function.prototype;
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.currentFunction = "";
this.currentArguments = [];
this.builtArguments = [];
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds["OnFunction"] = function(name)
{
return name.toLowerCase() == this.currentFunction.toLowerCase();
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts["CallFunction"] = function(name)
{
this.currentFunction = name;
this.currentArguments = this.builtArguments;
this.builtArguments = [];
this.runtime.trigger(pluginProto.cnds.OnFunction,this);
};
acts["AddParameter"] = function(value)
{
this.builtArguments.push(value);
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps["GetParameterCount"] = function(ret)
{
ret.set_int(this.currentArguments.length);
};
exps["GetParameter"] = function(ret,index)
{
var value = this.currentArguments[index];
if(typeof(value) == "undefined")
return ret.set_string("");
ret.set_any(value);
};
}());
;
;
cr.plugins_.Text = function(runtime)
{
this.runtime = runtime;
};
(function ()
{
var pluginProto = cr.plugins_.Text.prototype;
pluginProto.onCreate = function ()
{
pluginProto.acts.SetWidth = function (w)
{
if (this.width !== w)
{
this.width = w;
this.text_changed = true;	// also recalculate text wrapping
this.set_bbox_changed();
}
};
};
pluginProto.Type = function(plugin)
{
this.plugin = plugin;
this.runtime = plugin.runtime;
};
var typeProto = pluginProto.Type.prototype;
typeProto.onCreate = function()
{
};
pluginProto.Instance = function(type)
{
this.type = type;
this.runtime = type.runtime;
this.lines = [];		// for word wrapping
this.text_changed = true;
};
var instanceProto = pluginProto.Instance.prototype;
instanceProto.onCreate = function()
{
this.text = this.properties[0];
this.visible = (this.properties[1] === 0);	// 0=visible, 1=invisible
this.font = this.properties[2];
this.color = this.properties[3];
this.halign = this.properties[4];			// 0=left, 1=center, 2=right
var arr = this.font.split(" ");
var ptSize = 0;
var i;
for (i = 0; i < arr.length; i++)
{
if (arr[i].substr(arr[i].length - 2, 2) === "pt")
{
ptSize = parseInt(arr[i].substr(0, arr[i].length - 2));
this.pxHeight = Math.ceil((ptSize / 72.0) * 96.0) + 4;	// assume 96dpi...
break;
}
}
;
};
instanceProto.draw = function(ctx)
{
ctx.font = this.font;
ctx.textBaseline = "top";
ctx.fillStyle = this.color;
if (this.opacity !== 1.0)
ctx.globalAlpha = this.opacity;
if (this.text_changed)
{
this.lines = this.type.plugin.WordWrap(this.text, ctx, this.width);
this.text_changed = false;
}
var penX = this.x - (this.hotspotX * this.width);
var penY = this.y - (this.hotspotY * this.height);
var endY = penY + this.height;
var line_height = this.pxHeight;
var drawX;
var i;
for (i = 0; i < this.lines.length; i++)
{
drawX = penX;
if (this.halign === 1)		// center
drawX = penX + (this.width - this.lines[i].width) / 2;
else if (this.halign === 2)	// right
drawX = penX + (this.width - this.lines[i].width);
ctx.fillText(this.lines[i].text, drawX, penY);
penY += line_height;
if (penY >= endY - line_height)
break;
}
if (this.opacity !== 1.0)
ctx.globalAlpha = 1.0;
};
pluginProto.TokeniseWords = function (text)
{
var tokens = [];
var cur_word = "";
var ch;
var i = 0;
while (i < text.length)
{
ch = text.charAt(i);
if (ch === "\n")
{
if (cur_word.length)
{
tokens.push(cur_word);
cur_word = "";
}
tokens.push("\n");
++i;
}
else if (ch === " " || ch === "\t" || ch === "-")
{
do {
cur_word += text.charAt(i);
i++;
}
while (i < text.length && (text.charAt(i) === " " || text.charAt(i) === "\t"));
tokens.push(cur_word);
cur_word = "";
}
else if (i < text.length)
{
cur_word += ch;
i++;
}
}
if (cur_word.length)
tokens.push(cur_word);
return tokens;
};
pluginProto.WordWrap = function (text, ctx, width)
{
if (!text || !text.length)
return [];
if (width <= 2.0)
return [];
return this.WordWrapByWord(text, ctx, width);
};
pluginProto.WordWrapByWord = function (text, ctx, width)
{
var words = this.TokeniseWords(text);
var lines = [];
var cur_line = "";
var prev_line;
var line_width;
var i;
for (i = 0; i < words.length; i++)
{
if (words[i] === "\n")
{
var line = {};
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lines.push(line);
cur_line = "";
continue;
}
prev_line = cur_line;
cur_line += words[i];
line_width = ctx.measureText(cur_line).width;
if (line_width >= width)
{
var line = {};
line.text = prev_line;
line.width = ctx.measureText(prev_line).width;
lines.push(line);
cur_line = words[i];
}
}
if (cur_line.length)
{
var line = {};
line.text = cur_line;
line.width = ctx.measureText(cur_line).width;
lines.push(line);
}
return lines;
};
pluginProto.cnds = {};
var cnds = pluginProto.cnds;
cnds.CompareText = function(text_to_compare, case_sensitive)
{
if (case_sensitive)
return this.text == text_to_compare;
else
return this.text.toLowerCase() == text_to_compare.toLowerCase();
};
pluginProto.acts = {};
var acts = pluginProto.acts;
acts.SetText = function(param)
{
var text_to_set = param.toString();
if (this.text !== text_to_set)
{
this.text = text_to_set;
this.text_changed = true;
this.runtime.redraw = true;
}
};
acts.AppendText = function(param)
{
var text_to_append = param.toString();
if (text_to_append)	// not empty
{
this.text += text_to_append;
this.text_changed = true;
this.runtime.redraw = true;
}
};
pluginProto.exps = {};
var exps = pluginProto.exps;
exps.Text = function(ret)
{
ret.set_string(this.text);
};
}());
cr.getProjectModel = function() { return [
null,
null,
[
[
cr.plugins_.Text,
false,
true,
true,
true,
false,
true,
true
]
,	[
cr.plugins_.Function,
true,
false,
false,
false,
false,
false,
false
]
],
[
[
"t0",
cr.plugins_.Function,
null,
null,
[
]
]
,	[
"t1",
cr.plugins_.Text,
null,
null,
[
]
]
],
[
[
"Layout 1",
1280,
1024,
false,
"Event sheet 1",
[
[
"Layer 0",
0,
true,
"rgb(255, 255, 255)",
false,
1,
1,
1,
false,
[
[
[15, 18, 0, 544, 30, 0, 0, 1, 0, 0],
1,
[
],
[
],
[
"Every 3 seconds a function is called which sets the layer's opacity randomly.",
0,
"12pt Arial",
"rgb(0,0,0)",
0
]
]
]
]
],
[
]
]
],
[
[
"Event sheet 1",
[
[
0,
null,
[
[
-1,
cr.system_object.prototype.cnds.Every,
null,
false,
false,
false,
false
,[
[
0,
[
0,
3
]
]
]
]
],
[
[
0,
cr.plugins_.Function.prototype.acts.AddParameter,
null
,[
[
7,
[
19,
cr.system_object.prototype.exps.random
,[
[
0,
0
]
,[
0,
100
]
]
]
]
]
]
,			[
0,
cr.plugins_.Function.prototype.acts.CallFunction,
null
,[
[
7,
[
2,
"Hello world"
]
]
]
]
]
]
,		[
0,
null,
[
[
0,
cr.plugins_.Function.prototype.cnds.OnFunction,
null,
true,
false,
false,
false
,[
[
7,
[
2,
"Hello world"
]
]
]
]
],
[
[
-1,
cr.system_object.prototype.acts.SetLayerOpacity,
null
,[
[
5,
[
0,
0
]
]
,				[
0,
[
20,
0,
cr.plugins_.Function.prototype.exps.GetParameter,
null
,[
[
0,
0
]
]
]
]
]
]
]
]
]
]
],
"media/"
];};

window["cr"] = cr;
window["cr"]["createRuntime"] = cr.createRuntime;
